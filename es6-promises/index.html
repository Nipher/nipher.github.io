<!DOCTYPE html><html><head><meta charSet="utf-8" class="next-head next-head"/><title class="next-head">ES6 - Promises</title><meta name="description" content="Entenda ES6 promises e suas vantagens em operações assíncronas no javascript." class="next-head"/><meta name="viewport" content="initial-scale=1.0, width=device-width" class="next-head"/><meta name="twitter:card" content="summary_large_image" class="next-head"/><meta name="twitter:site" content="@nipher_jonas" class="next-head"/><meta name="twitter:title" content="ES6 - Promises" class="next-head"/><meta name="twitter:description" content="Entenda ES6 promises e suas vantagens em operações assíncronas no javascript." class="next-head"/><meta property="twitter:image:src" content="https://nipher.io/static/site.png" class="next-head"/><meta property="fb:admins" content="100001388969005" class="next-head"/><meta property="og:url" content="https://nipher.io/es6-promises" class="next-head"/><meta property="og:title" content="ES6 - Promises" class="next-head"/><meta property="og:image" content="https://nipher.io/static/site.png" class="next-head"/><meta property="og:description" content="Entenda ES6 promises e suas vantagens em operações assíncronas no javascript." class="next-head"/><meta property="og:site_name" content="Nipher" class="next-head"/><meta itemProp="name" content="ES6 - Promises" class="next-head"/><meta itemProp="description" content="Entenda ES6 promises e suas vantagens em operações assíncronas no javascript." class="next-head"/><meta itemProp="image" content="https://nipher.io/static/site.png" class="next-head"/><link rel="shortcut icon" href="/static/favicon.ico" type="image/x-icon" class="next-head"/><link rel="apple-touch-icon" sizes="57x57" href="/static/apple-touch-icon-57x57.png" class="next-head"/><link rel="apple-touch-icon" sizes="60x60" href="/static/apple-touch-icon-60x60.png" class="next-head"/><link rel="apple-touch-icon" sizes="72x72" href="/static/apple-touch-icon-72x72.png" class="next-head"/><link rel="apple-touch-icon" sizes="76x76" href="/static/apple-touch-icon-76x76.png" class="next-head"/><link rel="apple-touch-icon" sizes="114x114" href="/static/apple-touch-icon-114x114.png" class="next-head"/><link rel="apple-touch-icon" sizes="120x120" href="/static/apple-touch-icon-120x120.png" class="next-head"/><link rel="apple-touch-icon" sizes="144x144" href="/static/apple-touch-icon-144x144.png" class="next-head"/><link rel="apple-touch-icon" sizes="152x152" href="/static/apple-touch-icon-152x152.png" class="next-head"/><link rel="apple-touch-icon" sizes="180x180" href="/static/apple-touch-icon-180x180.png" class="next-head"/><link rel="icon" type="image/png" href="/static/favicon-16x16.png" sizes="16x16" class="next-head"/><link rel="icon" type="image/png" href="/static/favicon-32x32.png" sizes="32x32" class="next-head"/><link rel="icon" type="image/png" href="/static/favicon-96x96.png" sizes="96x96" class="next-head"/><link rel="icon" type="image/png" href="/static/android-chrome-192x192.png" sizes="192x192" class="next-head"/><meta name="msapplication-square70x70logo" content="/static/smalltile.png" class="next-head"/><meta name="msapplication-square150x150logo" content="/static/mediumtile.png" class="next-head"/><meta name="msapplication-square310x310logo" content="/static/largetile.png" class="next-head"/><link rel="preload" href="/_next/3f7341cb-ca9e-4cc8-a6ce-c4ffbc9e5551/page/post.js" as="script"/><link rel="preload" href="/_next/3f7341cb-ca9e-4cc8-a6ce-c4ffbc9e5551/page/_app.js" as="script"/><link rel="preload" href="/_next/3f7341cb-ca9e-4cc8-a6ce-c4ffbc9e5551/page/_error.js" as="script"/><link rel="preload" href="/_next/webpack/chunks/components_social_share_0a49c1be05a44c2c22400be9bd51a7a9-ba5984ee65adff24ec55.js" as="script"/><link rel="preload" href="/_next/static/commons/main-b3a0a6ab00828187c287.js" as="script"/><style id="__jsx-1204780744">.logo{position:relative;height:50px;width:50px;left:0;top:0;opacity:1;cursor:pointer;}</style><style id="__jsx-1462158505">.logo-piece.polygon-1 {
      clip-path: polygon(0% 0%, 33.3% 33.3%, 33.3% 0%);
      -webkit-clip-path: polygon(0% 0%, 33.3% 33.3%, 33.3% 0%);
      background: #333;
    }
.logo-piece.polygon-2 {
      clip-path: polygon(0% 0%, 0% 33.3%, 33.3% 33.3%);
      -webkit-clip-path: polygon(0% 0%, 0% 33.3%, 33.3% 33.3%);
      background: #333;
    }
.logo-piece.polygon-3 {
      clip-path: polygon(0% 33.3%, 33.3% 33.3%, 33.3% 66.6%);
      -webkit-clip-path: polygon(0% 33.3%, 33.3% 33.3%, 33.3% 66.6%);
      background: #333;
    }
.logo-piece.polygon-4 {
      clip-path: polygon(33.3% 0%, 66.6% 33.3%, 33.3% 33.3%);
      -webkit-clip-path: polygon(33.3% 0%, 66.6% 33.3%, 33.3% 33.3%);
      background: #333;
    }
.logo-piece.polygon-5 {
      clip-path: polygon(33.3% 33.3%, 66.6% 66.6%, 33.3% 66.6%);
      -webkit-clip-path: polygon(33.3% 33.3%, 66.6% 66.6%, 33.3% 66.6%);
      background: #333;
    }
.logo-piece.polygon-6 {
      clip-path: polygon(33.3% 33.3%, 66.6% 66.6%, 66.6% 33.3%);
      -webkit-clip-path: polygon(33.3% 33.3%, 66.6% 66.6%, 66.6% 33.3%);
      background: #333;
    }
.logo-piece.polygon-7 {
      clip-path: polygon(33.3% 66.6%, 66.6% 66.6%, 66.6% 100%);
      -webkit-clip-path: polygon(33.3% 66.6%, 66.6% 66.6%, 66.6% 100%);
      background: #333;
    }
.logo-piece.polygon-8 {
      clip-path: polygon(66.6% 33.3%, 66.6% 66.6%, 100% 66.6%);
      -webkit-clip-path: polygon(66.6% 33.3%, 66.6% 66.6%, 100% 66.6%);
      background: #333;
    }
.logo-piece.polygon-9 {
      clip-path: polygon(66.6% 66.6%, 66.6% 100%, 100% 100%);
      -webkit-clip-path: polygon(66.6% 66.6%, 66.6% 100%, 100% 100%);
      background: #333;
    }
.logo-piece.polygon-10 {
      clip-path: polygon(66.6% 66.6%, 100% 66.6%, 100% 100%);
      -webkit-clip-path: polygon(66.6% 66.6%, 100% 66.6%, 100% 100%);
      background: #333;
    }
.logo-piece.polygon-11 {
      clip-path: polygon(66.6% 0%, 100% 0%, 100% 33.3%);
      -webkit-clip-path: polygon(66.6% 0%, 100% 0%, 100% 33.3%);
      background: #333;
    }
.logo-piece.polygon-12 {
      clip-path: polygon(0% 66.6%, 33.3% 100%, 0% 100%);
      -webkit-clip-path: polygon(0% 66.6%, 33.3% 100%, 0% 100%);
      background: #333;
    }
 .photography-piece.polygon-1 {
      clip-path: polygon(30% 0%, 45% 56%, 63% 0%);
      -webkit-clip-path: polygon(30% 0%, 45% 56%, 63% 0%);
      background: #333;
    }
.photography-piece.polygon-2 {
      clip-path: polygon(0% 0%, 44% 56%, 29% 0%);
      -webkit-clip-path: polygon(0% 0%, 44% 56%, 29% 0%);
      background: #333;
    }
.photography-piece.polygon-3 {
      clip-path: polygon(64% 0%, 47% 52%, 99% 0%);
      -webkit-clip-path: polygon(64% 0%, 47% 52%, 99% 0%);
      background: #333;
    }
.photography-piece.polygon-4 {
      clip-path: polygon(47% 54%, 100% 32%, 100% 0%);
      -webkit-clip-path: polygon(47% 54%, 100% 32%, 100% 0%);
      background: #333;
    }
.photography-piece.polygon-5 {
      clip-path: polygon(100% 34%, 50% 54%, 100% 60%);
      -webkit-clip-path: polygon(100% 34%, 50% 54%, 100% 60%);
      background: #333;
    }
.photography-piece.polygon-6 {
      clip-path: polygon(100% 62%, 52% 55%, 100% 99%);
      -webkit-clip-path: polygon(100% 62%, 52% 55%, 100% 99%);
      background: #333;
    }
.photography-piece.polygon-7 {
      clip-path: polygon(99% 100%, 51% 55%, 80% 100%);
      -webkit-clip-path: polygon(99% 100%, 51% 55%, 80% 100%);
      background: #333;
    }
.photography-piece.polygon-8 {
      clip-path: polygon(79% 100%, 52% 58%, 39% 100%);
      -webkit-clip-path: polygon(79% 100%, 52% 58%, 39% 100%);
      background: #333;
    }
.photography-piece.polygon-9 {
      clip-path: polygon(0% 100%, 50% 60%, 38% 100%);
      -webkit-clip-path: polygon(0% 100%, 50% 60%, 38% 100%);
      background: #333;
    }
.photography-piece.polygon-10 {
      clip-path: polygon(48% 60.5%, 0% 63%, 0% 99%);
      -webkit-clip-path: polygon(48% 60.5%, 0% 63%, 0% 99%);
      background: #333;
    }
.photography-piece.polygon-11 {
      clip-path: polygon(0% 62%, 45% 60%, 0% 35%);
      -webkit-clip-path: polygon(0% 62%, 45% 60%, 0% 35%);
      background: #333;
    }
.photography-piece.polygon-12 {
      clip-path: polygon(0% 34%, 45% 59%, 0% 2%);
      -webkit-clip-path: polygon(0% 34%, 45% 59%, 0% 2%);
      background: #333;
    }
 .experiment-piece.polygon-1 {
      clip-path: polygon(20% 20%, 50% 95%, 80% 20%);
      -webkit-clip-path: polygon(20% 20%, 50% 95%, 80% 20%);
      background: #333;
    }
.experiment-piece.polygon-2 {
      clip-path: polygon(20% 20%, 50% 95%, 80% 20%);
      -webkit-clip-path: polygon(20% 20%, 50% 95%, 80% 20%);
      background: #333;
    }
.experiment-piece.polygon-3 {
      clip-path: polygon(0% 62%, 50% 20%, 100% 62%);
      -webkit-clip-path: polygon(0% 62%, 50% 20%, 100% 62%);
      background: #333;
    }
.experiment-piece.polygon-4 {
      clip-path: polygon(80% 20%, 88% 0%, 50% 20%);
      -webkit-clip-path: polygon(80% 20%, 88% 0%, 50% 20%);
      background: #333;
    }
.experiment-piece.polygon-5 {
      clip-path: polygon(20% 20%, 12% 0%, 50% 20%);
      -webkit-clip-path: polygon(20% 20%, 12% 0%, 50% 20%);
      background: #333;
    }
.experiment-piece.polygon-6 {
      clip-path: polygon(29% 44%, 45% 47%, 35% 46.5%);
      -webkit-clip-path: polygon(29% 44%, 45% 47%, 35% 46.5%);
      background: #fff;
    }
.experiment-piece.polygon-7 {
      clip-path: polygon(71% 44%, 55% 47%, 65% 46.5%);
      -webkit-clip-path: polygon(71% 44%, 55% 47%, 65% 46.5%);
      background: #fff;
    }
.experiment-piece.polygon-8 {
      clip-path: polygon(48% 66%, 50% 67%, 52% 66%);
      -webkit-clip-path: polygon(48% 66%, 50% 67%, 52% 66%);
      background: #fff;
    }
.experiment-piece.polygon-9 {
      clip-path: polygon(40% 55%, 44.2% 63%, 46% 65%);
      -webkit-clip-path: polygon(40% 55%, 44.2% 63%, 46% 65%);
      background: #fff;
    }
.experiment-piece.polygon-10 {
      clip-path: polygon(43% 55%, 45.8% 63%, 46% 65%);
      -webkit-clip-path: polygon(43% 55%, 45.8% 63%, 46% 65%);
      background: #fff;
    }
.experiment-piece.polygon-11 {
      clip-path: polygon(60% 55%, 55.8% 63%, 54% 65%);
      -webkit-clip-path: polygon(60% 55%, 55.8% 63%, 54% 65%);
      background: #fff;
    }
.experiment-piece.polygon-12 {
      clip-path: polygon(57% 55%, 54.1% 63%, 54% 65%);
      -webkit-clip-path: polygon(57% 55%, 54.1% 63%, 54% 65%);
      background: #fff;
    }
 .blog-piece.polygon-1 {
      clip-path: polygon(78.125% 21.875%, 78.125% 40.625%, 59.375% 40.625%);
      -webkit-clip-path: polygon(78.125% 21.875%, 78.125% 40.625%, 59.375% 40.625%);
      background: #333;
    }
.blog-piece.polygon-2 {
      clip-path: polygon(78.125% 21.875%, 59.375% 21.875%, 59.375% 40.625%);
      -webkit-clip-path: polygon(78.125% 21.875%, 59.375% 21.875%, 59.375% 40.625%);
      background: #333;
    }
.blog-piece.polygon-3 {
      clip-path: polygon(78.125% 40.625%, 59.375% 40.625%, 59.375% 59.375%);
      -webkit-clip-path: polygon(78.125% 40.625%, 59.375% 40.625%, 59.375% 59.375%);
      background: #333;
    }
.blog-piece.polygon-4 {
      clip-path: polygon(59.375% 21.875%, 59.375% 40.625%, 40.625% 40.625%);
      -webkit-clip-path: polygon(59.375% 21.875%, 59.375% 40.625%, 40.625% 40.625%);
      background: #333;
    }
.blog-piece.polygon-5 {
      clip-path: polygon(59.375% 40.625%, 59.375% 59.375%, 40.625% 59.375%);
      -webkit-clip-path: polygon(59.375% 40.625%, 59.375% 59.375%, 40.625% 59.375%);
      background: #333;
    }
.blog-piece.polygon-6 {
      clip-path: polygon(59.375% 40.625%, 40.625% 40.625%, 40.625% 59.375%);
      -webkit-clip-path: polygon(59.375% 40.625%, 40.625% 40.625%, 40.625% 59.375%);
      background: #333;
    }
.blog-piece.polygon-7 {
      clip-path: polygon(40.625% 59.375%, 59.375% 59.375%, 40.625% 78.125%);
      -webkit-clip-path: polygon(40.625% 59.375%, 59.375% 59.375%, 40.625% 78.125%);
      background: #333;
    }
.blog-piece.polygon-8 {
      clip-path: polygon(40.625% 59.375%, 40.625% 40.625%, 21.875% 59.375%);
      -webkit-clip-path: polygon(40.625% 59.375%, 40.625% 40.625%, 21.875% 59.375%);
      background: #333;
    }
.blog-piece.polygon-9 {
      clip-path: polygon(40.625% 59.375%, 40.625% 78.125%, 21.875% 78.125%);
      -webkit-clip-path: polygon(40.625% 59.375%, 40.625% 78.125%, 21.875% 78.125%);
      background: #333;
    }
.blog-piece.polygon-10 {
      clip-path: polygon(21.875% 59.375%, 40.625% 59.375%, 21.875% 78.125%);
      -webkit-clip-path: polygon(21.875% 59.375%, 40.625% 59.375%, 21.875% 78.125%);
      background: #333;
    }
.blog-piece.polygon-11 {
      clip-path: polygon(0% 50%, 12.5% 37.5%, 12.5% 62.5%);
      -webkit-clip-path: polygon(0% 50%, 12.5% 37.5%, 12.5% 62.5%);
      background: #333;
    }
.blog-piece.polygon-12 {
      clip-path: polygon(100% 50%, 87.5% 62.5%, 87.5% 37.5%);
      -webkit-clip-path: polygon(100% 50%, 87.5% 62.5%, 87.5% 37.5%);
      background: #333;
    }
 
        .polygon-1 {
          transition: -webkit-clip-path 0.39s 0.22s cubic-bezier(.7, .3, 0, 1), clip-path 0.39s 0.22s cubic-bezier(.7, .3, 0, 1), background-color 0.39s 0.22s cubic-bezier(.7, .3, 0, 1), border-radius 0.39s 0.22s cubic-bezier(.7, .3, 0, 1);
        }

        .polygon-2 {
          transition: -webkit-clip-path 0.48s 0.24000000000000002s cubic-bezier(.7, .3, 0, 1), clip-path 0.48s 0.24000000000000002s cubic-bezier(.7, .3, 0, 1), background-color 0.48s 0.24000000000000002s cubic-bezier(.7, .3, 0, 1), border-radius 0.48s 0.24000000000000002s cubic-bezier(.7, .3, 0, 1);
        }

        .polygon-3 {
          transition: -webkit-clip-path 0.5700000000000001s 0.26s cubic-bezier(.7, .3, 0, 1), clip-path 0.5700000000000001s 0.26s cubic-bezier(.7, .3, 0, 1), background-color 0.5700000000000001s 0.26s cubic-bezier(.7, .3, 0, 1), border-radius 0.5700000000000001s 0.26s cubic-bezier(.7, .3, 0, 1);
        }

        .polygon-4 {
          transition: -webkit-clip-path 0.6599999999999999s 0.28s cubic-bezier(.7, .3, 0, 1), clip-path 0.6599999999999999s 0.28s cubic-bezier(.7, .3, 0, 1), background-color 0.6599999999999999s 0.28s cubic-bezier(.7, .3, 0, 1), border-radius 0.6599999999999999s 0.28s cubic-bezier(.7, .3, 0, 1);
        }

        .polygon-5 {
          transition: -webkit-clip-path 0.75s 0.30000000000000004s cubic-bezier(.7, .3, 0, 1), clip-path 0.75s 0.30000000000000004s cubic-bezier(.7, .3, 0, 1), background-color 0.75s 0.30000000000000004s cubic-bezier(.7, .3, 0, 1), border-radius 0.75s 0.30000000000000004s cubic-bezier(.7, .3, 0, 1);
        }

        .polygon-6 {
          transition: -webkit-clip-path 0.8400000000000001s 0.32s cubic-bezier(.7, .3, 0, 1), clip-path 0.8400000000000001s 0.32s cubic-bezier(.7, .3, 0, 1), background-color 0.8400000000000001s 0.32s cubic-bezier(.7, .3, 0, 1), border-radius 0.8400000000000001s 0.32s cubic-bezier(.7, .3, 0, 1);
        }

        .polygon-7 {
          transition: -webkit-clip-path 0.9299999999999999s 0.34s cubic-bezier(.7, .3, 0, 1), clip-path 0.9299999999999999s 0.34s cubic-bezier(.7, .3, 0, 1), background-color 0.9299999999999999s 0.34s cubic-bezier(.7, .3, 0, 1), border-radius 0.9299999999999999s 0.34s cubic-bezier(.7, .3, 0, 1);
        }

        .polygon-8 {
          transition: -webkit-clip-path 1.02s 0.36s cubic-bezier(.7, .3, 0, 1), clip-path 1.02s 0.36s cubic-bezier(.7, .3, 0, 1), background-color 1.02s 0.36s cubic-bezier(.7, .3, 0, 1), border-radius 1.02s 0.36s cubic-bezier(.7, .3, 0, 1);
        }

        .polygon-9 {
          transition: -webkit-clip-path 1.1099999999999999s 0.38s cubic-bezier(.7, .3, 0, 1), clip-path 1.1099999999999999s 0.38s cubic-bezier(.7, .3, 0, 1), background-color 1.1099999999999999s 0.38s cubic-bezier(.7, .3, 0, 1), border-radius 1.1099999999999999s 0.38s cubic-bezier(.7, .3, 0, 1);
        }

        .polygon-10 {
          transition: -webkit-clip-path 1.2s 0.4s cubic-bezier(.7, .3, 0, 1), clip-path 1.2s 0.4s cubic-bezier(.7, .3, 0, 1), background-color 1.2s 0.4s cubic-bezier(.7, .3, 0, 1), border-radius 1.2s 0.4s cubic-bezier(.7, .3, 0, 1);
        }

        .polygon-11 {
          transition: -webkit-clip-path 1.29s 0.42000000000000004s cubic-bezier(.7, .3, 0, 1), clip-path 1.29s 0.42000000000000004s cubic-bezier(.7, .3, 0, 1), background-color 1.29s 0.42000000000000004s cubic-bezier(.7, .3, 0, 1), border-radius 1.29s 0.42000000000000004s cubic-bezier(.7, .3, 0, 1);
        }

        .polygon-12 {
          transition: -webkit-clip-path 1.3800000000000001s 0.44s cubic-bezier(.7, .3, 0, 1), clip-path 1.3800000000000001s 0.44s cubic-bezier(.7, .3, 0, 1), background-color 1.3800000000000001s 0.44s cubic-bezier(.7, .3, 0, 1), border-radius 1.3800000000000001s 0.44s cubic-bezier(.7, .3, 0, 1);
        }
 .polygon{position:absolute;height:100%;width:100%;opacity:1;background:#333;}
.polygon::before{content:"";width:100%;height:100%;background:rgba(255,255,255,0);top:0;left:0;position:absolute;}</style><style id="__jsx-3957473981">.menu-button.jsx-3957473981{position:relative;height:50px;width:50px;background:transparent;z-index:3;}
.menu-bar-1.jsx-3957473981{position:absolute;top:20px;left:50%;width:20px;height:2px;background:#333;-webkit-transform:translateX(-50%);-ms-transform:translateX(-50%);transform:translateX(-50%);-webkit-transition:-webkit-transform .3s ease-out;-webkit-transition:transform .3s ease-out;transition:transform .3s ease-out;}
.menu-bar-2.jsx-3957473981{position:absolute;top:auto;bottom:20px;left:50%;width:20px;height:2px;background:#333;-webkit-transform:translateX(-50%);-ms-transform:translateX(-50%);transform:translateX(-50%);-webkit-transition:-webkit-transform .3s ease-out;-webkit-transition:transform .3s ease-out;transition:transform .3s ease-out;}
.menu-button.jsx-3957473981 input[type=checkbox].jsx-3957473981{position:relative;height:100%;width:100%;opacity:0;cursor:pointer;z-index:1;}
input[type=checkbox].jsx-3957473981:checked~.menu-bar-1.jsx-3957473981{-webkit-transform:translate(-50%,4px) rotate(135deg);-ms-transform:translate(-50%,4px) rotate(135deg);transform:translate(-50%,4px) rotate(135deg);}
input[type=checkbox].jsx-3957473981:checked~.menu-bar-2.jsx-3957473981{-webkit-transform:translate(-50%,-4px) rotate(45deg);-ms-transform:translate(-50%,-4px) rotate(45deg);transform:translate(-50%,-4px) rotate(45deg);}</style><style id="__jsx-2047668845">.topbar.jsx-2047668845{padding:30px 70px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;}
@media (max-width:500px){.topbar.jsx-2047668845{padding:30px 15px;}}</style><style id="__jsx-624138856">.post-container p{font-family:'Open Sans', 'Helvetica Neue', Helvetica, 'Segoe UI', Arial, sans-serif;font-size:20px;font-weight:200;color:#333;line-height:32px;font-weight:300;max-width:50rem;margin-left:auto;margin-right:auto;}
.post-container h1{font-family:'Open Sans', 'Helvetica Neue', Helvetica, 'Segoe UI', Arial, sans-serif;font-size:40px;font-weight:600;max-width:50rem;margin-left:auto;margin-right:auto;}
.post-container h2{font-family:'Open Sans', 'Helvetica Neue', Helvetica, 'Segoe UI', Arial, sans-serif;font-size:32px;font-weight:600;max-width:50rem;margin-left:auto;margin-right:auto;}
.post-container h4{font-family:'Open Sans', 'Helvetica Neue', Helvetica, 'Segoe UI', Arial, sans-serif;margin:0;font-size:22px;font-weight:600;line-height:22px;color:#333;max-width:50rem;margin-left:auto;margin-right:auto;}
.post-container strong{font-weight:600;font-family:'Open Sans', 'Helvetica Neue', Helvetica, 'Segoe UI', Arial, sans-serif;}
.post-container time{display:block;font-family:'Open Sans', 'Helvetica Neue', Helvetica, 'Segoe UI', Arial, sans-serif;font-size:15px;font-weight:300;color:#515151;text-transform:uppercase;max-width:50rem;margin-left:auto;margin-right:auto;}
.post-container ul{list-style:inside circle !important;color:#666;font-size:18px;font-weight:200;max-width:50rem;margin-left:auto;margin-right:auto;}
.post-container ol{color:#666;font-size:18px;font-weight:200;list-style:inside decimal;max-width:50rem;margin-left:auto;margin-right:auto;padding-left:0;}
.post-container ol,.post-container li{margin-bottom:.5rem;}
.post-container blockquote{padding:0 0 0 10px;color:#999;border-left:10px solid #e5e5e5;max-width:50rem;margin-left:auto;margin-right:auto;}
.post-container blockquote p{color:#999;padding:0;}
.post-container pre{margin-left:-15px;padding:50px 15px;width:100vw;box-sizing:border-box;}
.post-container pre code{display:block;padding:0;font-size:16px;color:inherit;background-color:transparent;color:#fff;max-width:50rem;margin-left:auto;margin-right:auto;}
.post-container code{color:#fff;background-color:#7f7f7f;padding:2px 3px;font-size:13px;}
.post-container a{font-family:'Open Sans', 'Helvetica Neue', Helvetica, 'Segoe UI', Arial, sans-serif;font-size:20px;font-weight:300;color:#268bd2;}
#disqus_thread{max-width:50rem;margin-left:auto;margin-right:auto;}
.share{text-align:center;border-top:1px solid #e5e5e5;margin-top:55px;}
.share svg{margin:2rem .938rem;width:35px;height:35px;}
@media (min-width:500px){.post-container pre{padding:50px 70px;margin-left:-70px;}.post-container blockquote{-webkit-transform:translateX(10px);-ms-transform:translateX(10px);transform:translateX(10px);}}</style><style id="__jsx-394600245">.fade-in.jsx-394600245{opacity:0;-webkit-animation:2s fadeIn-jsx-394600245 ease forwards;animation:2s fadeIn-jsx-394600245 ease forwards;}
@-webkit-keyframes fadeIn-jsx-394600245{from{opacity:0;}to{opacity:1;}}
@keyframes fadeIn-jsx-394600245{from{opacity:0;}to{opacity:1;}}</style><style id="__jsx-634012247">p{font-size:20px;}
pre{background-color:#060606;font-size:20px;padding:20px;overflow-x:auto;white-space:pre;}
pre code{padding:0;}
code{color:#fff;background-color:#060606;font-size:65%;border-radius:3px;padding:2px 5px;}
.hljs-comment,.hljs-quote{color:#969896;}
.hljs-variable,.hljs-template-variable,.hljs-tag,.hljs-name,.hljs-selector-id,.hljs-selector-class,.hljs-regexp,.hljs-deletion{color:#cc6666;}
.hljs-literal{color:#4aa3df;}
.hljs-builtin-name,.hljs-type,.hljs-meta,.hljs-link{color:#EB9532;}
.hljs-built_in,.hljs-params{color:#cc6666;}
.hljs-attribute{color:#f0c674;}
.hljs-string,.hljs-symbol,.hljs-bullet,.hljs-addition{color:#EB9532;}
.hljs-number,.hljs-title,.hljs-section{color:#47D2E9;}
.hljs-keyword,.hljs-selector-tag{color:#4aa3df;font-weight:bold;}
.hljs{overflow-x:auto;background-color:#060606;color:#fff;}
.hljs-emphasis{font-style:italic;}
.hljs-strong{font-weight:bold;}</style><style id="__jsx-784795864">a{color:inherit;-webkit-text-decoration:none;text-decoration:none;}
ul{list-style-type:none;margin:0;padding:0;}
.hidden{display:none;}
body{height:100%;}
html{height:100%;}
.page-content{padding:0 70px 30px 70px;position:relative;}
@media (max-width:500px){.page-content{padding:0 15px 30px 15px;}}
.polygon{position:absolute;height:100%;width:100%;opacity:1;background:#333;}
.polygon::before{content:"";width:100%;height:100%;background:rgba(255,255,255,0);top:0;left:0;position:absolute;}</style><style id="__jsx-2827779536">html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;}
body{margin:0;}
article,aside,footer,header,nav,section{display:block;}
h1{font-size:2em;margin:0.67em 0;}
figcaption,figure,main{display:block;}
figure{margin:1em 40px;}
hr{box-sizing:content-box;height:0;overflow:visible;}
pre{font-family:monospace,monospace;font-size:1em;}
a{background-color:transparent;-webkit-text-decoration-skip:objects;}
abbr[title]{border-bottom:none;-webkit-text-decoration:underline;text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted;}
b,strong{font-weight:inherit;}
b,strong{font-weight:bolder;}
code,kbd,samp{font-family:monospace,monospace;font-size:1em;}
dfn{font-style:italic;}
mark{background-color:#ff0;color:#000;}
small{font-size:80%;}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline;}
sub{bottom:-0.25em;}
sup{top:-0.5em;}
audio,video{display:inline-block;}
audio:not([controls]){display:none;height:0;}
img{border-style:none;}
svg:not(:root){overflow:hidden;}
button,input,optgroup,select,textarea{font-family:sans-serif;font-size:100%;line-height:1.15;margin:0;}
button,input{overflow:visible;}
button,select{text-transform:none;}
button,html [type="button"],[type="reset"],[type="submit"]{-webkit-appearance:button;}
button::-moz-focus-inner,[type="button"]::-moz-focus-inner,[type="reset"]::-moz-focus-inner,[type="submit"]::-moz-focus-inner{border-style:none;padding:0;}
button:-moz-focusring,[type="button"]:-moz-focusring,[type="reset"]:-moz-focusring,[type="submit"]:-moz-focusring{outline:1px dotted ButtonText;}
fieldset{padding:0.35em 0.75em 0.625em;}
legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal;}
progress{display:inline-block;vertical-align:baseline;}
textarea{overflow:auto;}
[type="checkbox"],[type="radio"]{box-sizing:border-box;padding:0;}
[type="number"]::-webkit-inner-spin-button,[type="number"]::-webkit-outer-spin-button{height:auto;}
[type="search"]{-webkit-appearance:textfield;outline-offset:-2px;}
[type="search"]::-webkit-search-cancel-button,[type="search"]::-webkit-search-decoration{-webkit-appearance:none;}
::-webkit-file-upload-button{-webkit-appearance:button;font:inherit;}
details,menu{display:block;}
summary{display:list-item;}
canvas{display:inline-block;}
template{display:none;}
[hidden]{display:none;}</style></head><body><div id="__next"><div class="page-container"><header class="jsx-2047668845 topbar"><div class="jsx-1462158505 logo root undefined logo"><div class="jsx-1462158505 logo-piece polygon-1 polygon "></div><div class="jsx-1462158505 logo-piece polygon-2 polygon "></div><div class="jsx-1462158505 logo-piece polygon-3 polygon "></div><div class="jsx-1462158505 logo-piece polygon-4 polygon "></div><div class="jsx-1462158505 logo-piece polygon-5 polygon "></div><div class="jsx-1462158505 logo-piece polygon-6 polygon "></div><div class="jsx-1462158505 logo-piece polygon-7 polygon "></div><div class="jsx-1462158505 logo-piece polygon-8 polygon "></div><div class="jsx-1462158505 logo-piece polygon-9 polygon "></div><div class="jsx-1462158505 logo-piece polygon-10 polygon "></div><div class="jsx-1462158505 logo-piece polygon-11 polygon "></div><div class="jsx-1462158505 logo-piece polygon-12 polygon "></div></div><div class="jsx-3957473981 menu-button "><input type="checkbox" class="jsx-3957473981"/><div class="jsx-3957473981 menu-bar-1"></div><div class="jsx-3957473981 menu-bar-2"></div></div></header><div class="page-content "><section><article itemProp="articleBody" class="jsx-394600245 post-container fade-in"><h1 itemProp="name" class="jsx-394600245 post-title">ES6 - Promises</h1><p itemProp="description" class="jsx-394600245">Entenda ES6 promises e suas vantagens em operações assíncronas no javascript.</p><time itemProp="datePublished" dateTime="2016-04-08 18:40:43 -0300" class="jsx-394600245">08 Apr 2016</time><div class="jsx-394600245"><p>E ai galera, vamos continuar a série &quot;ES6 - O que mudou?&quot; :)</p>
<p>Esse post será sobre promises</p>
<p>Lista dos tópicos que irei abordar:</p>
<ul>
<li>O que é uma Promise?</li>
<li>States</li>
<li>Constructor</li>
<li>Instance Methods</li>
<li>Static Methods</li>
<li>Chaining</li>
<li>Error handling</li>
<li>Parallelism and sequencing</li>
</ul>
<p>Vamos começar</p>
<h2>O que é uma Promise?</h2>
<p>Promise é um objeto usado para representar uma operação que ainda não foi completada, mas que eventualmente será finalizada no futuro.</p>
<p>Esse objeto tem uma API que te permite fazer algo assim que ela acabar, recebendo o resultado dessa operação como parâmetro.</p>
<p>&quot;Ta, mas eu já faço isso com callback&quot;</p>
<p>Usar promises tem diversas vantagens, ela te permite manipular o resultado de uma ou várias operações assíncronas com mais facilidade e organização.
<strong>Promise é uma das soluções para o callback hell.</strong></p>
<p>Então, vamos ver um pequeno exemplo utilizando uma callback comum, para relembrar como fazemos operações assíncronas sem promises.</p>
<p>Digamos que nós temos uma função <code>fetch</code> que faz requests HTTP para um servidor.</p>
<pre><code class="language-javascript">fetch(<span class="hljs-string">'/data.json'</span>, (err, data) =&gt; {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-comment">// handle error</span>
  }

  <span class="hljs-comment">// handle data from server</span>
});
</code></pre>
<p>Ok, temos uma callback que recebe 2 parâmetros, um <code>err</code> (caso tenha ocorrido algum erro) e um <code>data</code> (dados que o servidor retornou para a nossa aplicação).</p>
<p>Agora vamos ver como fazemos a mesma operação, sendo que a função <code>fetch</code> irá retornar uma promise dessa vez.</p>
<pre><code class="language-javascript">fetch(<span class="hljs-string">'/data.json'</span>)
  .then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
    <span class="hljs-comment">// handle data from server</span>
  })
  .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
    <span class="hljs-comment">// handle error</span>
  });
</code></pre>
<p>Dessa vez, chamamos 2 métodos, o <code>then</code> (que é chamado recebendo o dado do backend caso tudo tenha dado certo) e o <code>catch</code> (que é chamado recebendo um erro caso algo tenha dado errado), falarei mais sobre eles ao decorrer do post.</p>
<h2>States</h2>
<p>Uma promise só pode ter 3 possíveis estados:</p>
<ul>
<li>Pending</li>
<li>Fulfilled</li>
<li>Rejected</li>
</ul>
<p>Pendente, resolvida ou rejeitada.</p>
<p>Caso o status atual seja pendente, a operação ainda não acabou e nenhuma callback passada para os métodos <code>then</code> ou <code>catch</code> foi invocada ainda.</p>
<p>Se resolvida, o valor recebido é o valor que a operação retorna, quando a operação for executada sem problemas (parâmetro recebido no <code>then</code>).</p>
<p>Se rejeitada, o valor é uma informação de erro, avisando que algo deu errado na operação e descrevendo a razão do acontecido (parâmetro recebido no <code>catch</code>).</p>
<p><strong>Uma promise não pode ser resolvida e em seguida rejeitada ou vice e versa</strong>, a única transição de estado que ela sofre, é de pendente para uma das duas (resolvida ou rejeitada).</p>
<h2>Constructor</h2>
<p>Então, qual é a sintaxe usada para criarmos uma promise em ES6?</p>
<p>Para criarmos uma instância de uma Promise, vamos usar o construtor <code>Promise(..)</code>.</p>
<p>Como exemplo, vamos ver uma representação do que acontece dentro da função <code>fetch</code>, que foi usada anteriormente.</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetch</span> (<span class="hljs-params">url</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve , reject</span>) =&gt;</span> {
    <span class="hljs-comment">// Faz o request HTTP (assíncrono)</span>
    <span class="hljs-comment">// dentro da callback do request chama `resolve(..)` ou `reject(..)`</span>
  }); 
}
</code></pre>
<p>No código acima, dentro da função <code>fetch</code> estamos retornando uma nova Promise, criada por nós. O construtor dessa Promise, recebe uma função como parâmetro e essa função recebe dois parâmetros (<code>resolve</code> e <code>reject</code>), que também são funções.</p>
<p>Então, quando queremos que a nossa promise, seja resolvida, chamamos a função que recebemos como parâmetro <code>resolve('Some data')</code>, e no caso de erro, chamamos o <code>reject('Error description')</code> que também recebemos como parâmetro.</p>
<p>Vamos implementar um <code>fetch</code> falso que chamaria <code>resolve</code> depois de uma operação assíncrona, no exemplo usaremos o <code>setTimeout</code> para simular algo assíncrono.</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetch</span> (<span class="hljs-params">url</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve , reject</span>) =&gt;</span> {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(<span class="hljs-string">'Some data'</span>), <span class="hljs-number">1000</span>);
  }); 
}

fetch(<span class="hljs-string">'/some-url'</span>)
  .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(data));

<span class="hljs-comment">// &gt; 'Some data'</span>
</code></pre>
<p>Como podemos ver no exemplo, a callback passada para o método <code>then</code> recebe o dado <code>'Some data'</code>, que é a string que passamos para a função <code>resolve</code>.</p>
<p>Agora vamos ver um exemplo parecido, mas dessa vez chamaremos a função <code>reject</code>.</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetch</span> (<span class="hljs-params">url</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve , reject</span>) =&gt;</span> {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> reject(<span class="hljs-built_in">Error</span>(<span class="hljs-string">'Something went wrong'</span>)), <span class="hljs-number">1000</span>);
  }); 
}

fetch(<span class="hljs-string">'/some-url'</span>)
  .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(data))
  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err));

<span class="hljs-comment">// &gt; Error: Something went wrong</span>
</code></pre>
<p>Nesse exemplo, vemos a callback passada para o método <code>catch</code> sendo executada recebendo o dado <code>'Something went wrong'</code> como o parâmetro <code>err</code>.
Algo importante a citar, é que o <code>then</code> <strong>não é executado</strong> nesse caso, porque quando o <code>reject</code> é chamado, ele pula para o primeiro <code>catch</code>.</p>
<h2>Instance Methods</h2>
<p>Os métodos de uma instância de <code>Promise</code>, são o <code>then</code> e o <code>catch</code>.</p>
<h4>then(..)</h4>
<p>O método <code>then</code>, recebe uma callback de sucesso que será executada quando a promise for resolvida e uma segunda callback que será executada quando a promise for rejeitada.</p>
<p>Exemplo:</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetch</span> (<span class="hljs-params">url</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve , reject</span>) =&gt;</span> {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> reject(<span class="hljs-built_in">Error</span>(<span class="hljs-string">'Something went wrong'</span>)), <span class="hljs-number">1000</span>);
  }); 
}

fetch(<span class="hljs-string">'/some-url'</span>)
  .then(
    <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(data),
    err =&gt; <span class="hljs-built_in">console</span>.log(err)
  );

<span class="hljs-comment">// &gt; Error: Something went wrong</span>
</code></pre>
<p>No exemplo acima, ao invés de usarmos <code>catch</code> passamos a callback de erro como o segundo parâmetro do <code>then</code>.</p>
<p>No final das contas, não faz diferença entre fazer dessa forma ou usar o <code>catch</code>, eu pessoalmente gosto de usar o <code>catch</code>, acho que fica mais claro e organizado.</p>
<h4>catch(..)</h4>
<p>Como visto nos exemplos anteriores, o método <code>catch</code> recebe uma única callback, para tratar de um erro que possa ter ocorrido na operação, quando a promise é rejeitada.</p>
<p><strong>Esses dois métodos retornam uma promise.</strong></p>
<p>&quot;Oi? o.O&quot;</p>
<p>Isso mesmo, como você já deve ter reparado nos exemplos, o <code>catch</code> está sendo chamado logo após o <code>then</code>, ou seja, é executado o método <code>catch</code> do retorno do <code>then</code>, isso funciona porque eles retornam uma promise.</p>
<p>&quot;Então quer dizer que eu posso chamar o método <code>then</code> depois do <code>catch</code> também?&quot;</p>
<p>Isso mesmo, podemos até chamar <code>then</code> depois de <code>then</code>.</p>
<p>Mostrarei como isso faz sentido no tópico &quot;chaining&quot;.</p>
<h2>Static Methods</h2>
<p>Assim como podemos criar promises <code>new Promise((resolve, reject) =&gt; { .. })</code> podemos também chamar métodos estáticos dessa referência (<code>Promise</code>).</p>
<p>Temos alguns métodos que podemos usar, que são bem úteis.</p>
<ul>
<li>all(iterable)</li>
<li>race(iterable)</li>
<li>resolve(value)</li>
<li>reject(reason)</li>
</ul>
<h4>all([..])</h4>
<p>O método <code>Promise.all(..)</code> recebe como parâmetro um array contendo promises e retorna uma promise que ou será resolvida apenas quando <strong>todas</strong> as promises do array estiverem resolvidas ou rejeitada assim que <strong>uma</strong> delas for rejeitada.</p>
<p>Vamos ver um exemplo sem <code>catch</code>:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">let</span> promises = [];

promises.push(fetch(<span class="hljs-string">'/some-url/1'</span>));
promises.push(fetch(<span class="hljs-string">'/some-url/2'</span>));
promises.push(fetch(<span class="hljs-string">'/some-url/3'</span>));

<span class="hljs-built_in">Promise</span>.all(promises)
  .then(<span class="hljs-function"><span class="hljs-params">responses</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(responses));

<span class="hljs-comment">// &gt; ['Some data 1  ', 'Some data 2', 'Some data 3']</span>
</code></pre>
<p>Então, recapitulando o que aconteceu acima</p>
<ol>
<li>Chamamos a nossa função <code>fetch</code> 3 vezes, para cada chamada é retornado uma promise diferente e adicionamos a promise retornada em um array.</li>
<li>Acessamos o método estático <code>all</code> da referência global <code>Promise</code> e passamos o array (<code>promises</code>) como parâmetro.</li>
<li>Como o método <code>all</code> retorna uma promise, estamos dando um <code>then</code> logo em seguida do <code>all</code>.</li>
<li>A callback que passamos para o <code>then</code> está recebendo um array de resultados, os resultados estão na mesma ordem das promises que existem dentro do array, logo <code>responses[0]</code> seria a resposta de <code>promises[0]</code>.</li>
</ol>
<p>Vamos ver um exemplo igual, mas com uma das promises sendo rejeitada.</p>
<p>Digamos que nesse exemplo, quando chamamos o <code>fetch</code> com <code>/some-url/2</code> a promise retornada seja rejeitada, teriamos um array de 2 promises que serão resolvidas e 1 rejeitada. Vamos ver o que acontece.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">let</span> promises = [];

promises.push(fetch(<span class="hljs-string">'/some-url/1'</span>));
promises.push(fetch(<span class="hljs-string">'/some-url/2'</span>));
promises.push(fetch(<span class="hljs-string">'/some-url/3'</span>));

<span class="hljs-built_in">Promise</span>.all(promises)
  .then(<span class="hljs-function"><span class="hljs-params">responses</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(responses))
  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err));

<span class="hljs-comment">// &gt; Error: Something went wrong</span>
</code></pre>
<p>Então, aconteceu a mesma coisa quando temos uma promise rejeitada, o <code>then</code> foi ignorado, e fomos parar direto no <code>catch</code> com apenas uma mensagem de erro que veio da segunda promise do array.</p>
<p>Vale citar que as outras operações ainda serão executadas, elas não são abortadas, porém, a callback do <code>then</code> mesmo assim não será chamada.</p>
<h4>race([..])</h4>
<p>O método <code>Promise.race(..)</code> também recebe como parâmetro um array contendo promises e retorna uma promise que ou será resolvida assim que <strong>qualquer uma</strong> das promises do array estiverem resolvida ou rejeitada assim que <strong>qualquer uma</strong> delas for rejeitada.</p>
<p>Vamos ver um exemplo em que a segunda promise foi a primeira que foi resolvida:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">let</span> promises = [];

promises.push(fetch(<span class="hljs-string">'/some-url/1'</span>));
promises.push(fetch(<span class="hljs-string">'/some-url/2'</span>));
promises.push(fetch(<span class="hljs-string">'/some-url/3'</span>));

<span class="hljs-built_in">Promise</span>.race(promises)
  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(response))
  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err));

<span class="hljs-comment">// &gt; 'Some data 2'</span>
</code></pre>
<p>O exemplo é muito similar com o do <code>Promise.all([..])</code>, a única difereça, é que estamos chamando o método <code>race</code> e em vez de recebermos um array de resultados na callback do then, estamos recebendo o resultado da promise que foi resolvida primeiro.</p>
<p>No caso em que uma das promises for rejeitada, acontecerá a mesma coisa que aconteceu no exemplo do <code>Promise.all([..])</code>, a callback do <code>then</code> não será executada, e teremos o erro da promise que foi rejeitada.</p>
<p>Lembrando de novo, que não acontece nenhum tipo de cancelamento das outras operações, promises não tem um método para isso.</p>
<h4>resolve(..)</h4>
<p>Esse método é bem simples, ele retorna uma promise já resolvida, e recebe como parâmetro o valor que a callback do <code>then</code> receberá.</p>
<p>Exemplo:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">let</span> promise = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'My data'</span>);

promise
  .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(data));

<span class="hljs-comment">// &gt; 'My data'</span>
</code></pre>
<h4>reject(..)</h4>
<p>Esse método é o contrário do <code>Promise.resolve(..)</code>, ele retorna uma promise já rejeitada, e recebe como parâmetro o valor que a callback do <code>catch</code> receberá (o motivo da rejeição).</p>
<p>Exemplo:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">let</span> promise = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-built_in">Error</span>(<span class="hljs-string">'Some reason'</span>));

promise
  .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(data))
  .catch(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(reason));

<span class="hljs-comment">// &gt; Error: Some reason</span>
</code></pre>
<h2>Chaining</h2>
<p>Então, lembram quando eu mencionei que podemos chamar <code>then</code> / <code>catch</code> seguido de outro <code>then</code> / <code>catch</code>?</p>
<p>Isso se chama chaining, nesse tópico vamos descobrir que <code>then</code> não é o fim da estrada.</p>
<p>Podemos usar essa tática para processar dados ou executar mais operações assíncronas.</p>
<h4>Processando dados</h4>
<p>Você pode processar um dado que foi retornado em uma promise e continuar encadeamento de &quot;thens&quot;, simplesmente retornando um novo valor dentro da callback.</p>
<p>Exemplo:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">let</span> promise = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>);

promise
  .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> data + <span class="hljs-number">1</span>)
  .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(data));

<span class="hljs-comment">// &gt; 3</span>
</code></pre>
<p>Acima, definimos uma promise já resolvida com o valor <code>2</code>, chamamos o método <code>then</code> passando uma callback que retorna <code>data + 1</code> e em seguida colocamos mais um <code>then</code> que loga seu <code>data</code>.</p>
<p>O <code>data</code> do segundo <code>then</code> é o retorno do primeiro.</p>
<p>Então isso te permite criar um flow de execução bem limpo.</p>
<p>Digamos que chamamos o método <code>fetch</code> pegando um json, mas esse json vem como string, e queremos transforma-lo em objeto.</p>
<p>Exemplo:</p>
<pre><code class="language-javascript">fetch(<span class="hljs-string">'/data.json'</span>)
  .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-built_in">JSON</span>.parse(data))
  .then(<span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(obj));

&gt; { <span class="hljs-attr">name</span>: <span class="hljs-string">'Promise'</span> }
</code></pre>
<p>Nesse exemplo, recebemos uma string <code>'{ &quot;name&quot;: &quot;Promise&quot; }'</code>, e transformamos ela em um objeto javascript chamando o método <code>JSON.parse</code> retornando o novo objeto para o próximo <code>then</code> que apenas loga o objeto.</p>
<h4>Executando mais operações assíncronas</h4>
<p>Você pode encadear &quot;thens&quot; para executar mais operações assíncronas, em sequência da anterior.</p>
<p>Quando você retorna um valor na callback do <code>then</code> a callback do próximo <code>then</code> irá receber esse valor, mas se você retornar uma outra promise a próxima execução irá aguardar que essa promise seja resolvida ou rejeitada.</p>
<p>Exemplo:</p>
<pre><code class="language-javascript">fetch(<span class="hljs-string">'/data.json'</span>)
  .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-built_in">JSON</span>.parse(data))
  .then(<span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> { <span class="hljs-attr">name</span>: obj.name, <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() })
  .then(<span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> fetch(<span class="hljs-string">'/save'</span>, { <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>, <span class="hljs-attr">body</span>: obj }))
  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(response));

<span class="hljs-comment">// &gt; 'Done.'</span>
</code></pre>
<ol>
<li>Usamos o <code>fetch</code> mais uma vez para fazer requests para uma API</li>
<li>Pegamos um json da API</li>
<li>Parseamos esse json</li>
<li>Retornamos um novo objeto com a propriedade <code>name</code> e com uma nova propriedade <code>date</code> recebendo a data atual</li>
<li>Usamos o fetch novamente passando esse novo objeto para outra rota da API</li>
<li>Quando o novo request acabar, o próximo <code>then</code> será executado, e logamos a resposta.</li>
</ol>
<p>Agora, parem para pensar como isso ficaria sem promises...</p>
<p>Pois é, quando disse que promise é uma das soluções para o callback hell, foi isso que eu quis dizer.</p>
<h2>Error handling</h2>
<p>Já vimos a utilização do <code>catch</code> em alguns exemplos, usaremos o <code>catch</code> bastante para tratar os erros que acontecem nessas operações com promises.</p>
<p>A callback que passamos pro<code>catch</code> será chamada caso a etapa anterior a ele der algum erro ou retornar uma promise rejeitada.</p>
<p>Exemplo:</p>
<pre><code class="language-javascript"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'Data'</span>)
  .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-built_in">Error</span>(<span class="hljs-string">'Fail'</span>)))
  .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'yay'</span>))
  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err));

<span class="hljs-comment">// &gt; Error: Fail</span>
</code></pre>
<p>No exemplo, temos uma promise que foi resolvida, mas ao <code>then</code> ser executado, retornamos uma promise rejeitada, causando a execução do próximo <code>catch</code>.</p>
<p>Com isso, dentro de &quot;thens&quot; podemos fazer checagens e retornar uma promise rejeitada para forçar a entrada no próximo <code>catch</code>, porque checamos que algo deu errado e no <code>catch</code> tratamos esse erro.</p>
<p>O mesmo acontece quando um <code>throw</code> ocorre dentro de alguma etapa.</p>
<p>Exemplo:</p>
<pre><code class="language-javascript"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'Data'</span>)
  .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-built_in">JSON</span>.parse(data))
  .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'yay'</span>))
  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err));

<span class="hljs-comment">// &gt; SyntaxError: Unexpected token D</span>
<span class="hljs-comment">//       at Object.parse (native) ...</span>
</code></pre>
<p>Nó código acima, quando executamos o método <code>JSON.parse</code> passando <code>data</code> como parâmetro ocorre um <code>throw SyntaxError(..)</code>. O que causa a execução direta do <code>catch</code>.</p>
<p>Como podemos ver o <code>throw</code> não saiu do escopo do nosso encadeamento, permitindo o tratamento do erro, exibindo uma mensagem para o usuário ou até mesmo corrigindo o problema, sem afetar o funcionamento da aplicação.</p>
<h2>Parallelism and sequencing</h2>
<p>Por último, vou mostrar duas formas de executarmos operações assim dinamicamente, utilizando métodos que nós temos nativamente em um <code>Array</code>.</p>
<h4>Paralellism</h4>
<p>Imaginem que temos um array de itens que queremos salvar através de uma API, e queremos mandar salvar todos eles em paralelo e fazer algo assim que cada operação acabar.</p>
<p>Exemplo:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">let</span> items = [{ <span class="hljs-attr">name</span>: <span class="hljs-string">'es5'</span> }, { <span class="hljs-attr">name</span>: <span class="hljs-string">'es6'</span> }, { <span class="hljs-attr">name</span>: <span class="hljs-string">'es7'</span> }, { <span class="hljs-attr">name</span>: <span class="hljs-string">'es8'</span> }];

items.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
  fetch(<span class="hljs-string">'/save'</span>, { <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>, <span class="hljs-attr">body</span>: obj })
    .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(res));
});

<span class="hljs-comment">// &gt; 'es6 Done.'</span>
<span class="hljs-comment">// &gt; 'es8 Done.'</span>
<span class="hljs-comment">// &gt; 'es5 Done.'</span>
<span class="hljs-comment">// &gt; 'es7 Done.'</span>
</code></pre>
<p>Nesse exemplo, podemos ver que não importa a ordem de finalização de nossas operações, queremos que a nossa callback seja executada assim que a operação acabar.</p>
<p>No output do console, podemos ver que o es6 foi o primeiro a terminar, o es8 foi o segundo, es5 terceiro e es7 o quarto.</p>
<p>Não queremos que seja sequencial, na ordem que está no array, só queremos que todos sejam salvos em paralelo e que nossas callbacks sejam executadas assim que sua respectiva promise for resolvida.</p>
<h4>Sequencing</h4>
<p>Imaginem o mesmo array, a mesma operação, porém não queremos continuar salvando esses itens caso uma das operações falhe ou que queremos salva-los sequencialmente, na ordem que está no array.</p>
<p>Exemplo:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">let</span> items = [{ <span class="hljs-attr">name</span>: <span class="hljs-string">'es5'</span> }, { <span class="hljs-attr">name</span>: <span class="hljs-string">'es6'</span> }, { <span class="hljs-attr">name</span>: <span class="hljs-string">'es7'</span> }, { <span class="hljs-attr">name</span>: <span class="hljs-string">'es8'</span> }];

items.reduce(<span class="hljs-function">(<span class="hljs-params">sequence, obj</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> sequence
    .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> fetch(<span class="hljs-string">'/save'</span>, { <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>, <span class="hljs-attr">body</span>: obj }))
    .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(res));
}, <span class="hljs-built_in">Promise</span>.resolve());

<span class="hljs-comment">// &gt; 'es5 Done.'</span>
<span class="hljs-comment">// &gt; 'es6 Done.'</span>
<span class="hljs-comment">// &gt; 'es7 Done.'</span>
<span class="hljs-comment">// &gt; 'es8 Done.'</span>
</code></pre>
<p>Nesse exemplo podemos ver que criamos um encadeamento dinamico, não importa a quantidade de itens que temos no array, todos eles serão salvos na ordem que estão no array.</p>
<p>O método reduce no final das contas, é a mesma coisa que esse código:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">let</span> items = [{ <span class="hljs-attr">name</span>: <span class="hljs-string">'es5'</span> }, { <span class="hljs-attr">name</span>: <span class="hljs-string">'es6'</span> }, { <span class="hljs-attr">name</span>: <span class="hljs-string">'es7'</span> }, { <span class="hljs-attr">name</span>: <span class="hljs-string">'es8'</span> }];

<span class="hljs-built_in">Promise</span>.resolve()
  .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> fetch(<span class="hljs-string">'/save'</span>, { <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>, <span class="hljs-attr">body</span>: items[<span class="hljs-number">0</span>] }))
  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(res))
  .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> fetch(<span class="hljs-string">'/save'</span>, { <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>, <span class="hljs-attr">body</span>: items[<span class="hljs-number">1</span>] }))
  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(res))
  .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> fetch(<span class="hljs-string">'/save'</span>, { <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>, <span class="hljs-attr">body</span>: items[<span class="hljs-number">2</span>] }))
  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(res))
  .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> fetch(<span class="hljs-string">'/save'</span>, { <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>, <span class="hljs-attr">body</span>: items[<span class="hljs-number">3</span>] }))
  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(res));

<span class="hljs-comment">// &gt; 'es5 Done.'</span>
<span class="hljs-comment">// &gt; 'es6 Done.'</span>
<span class="hljs-comment">// &gt; 'es7 Done.'</span>
<span class="hljs-comment">// &gt; 'es8 Done.'</span>
</code></pre>
<p>Porém, com <code>reduce</code>, não importa a quantidade de items, conseguimos fazer operações baseadas em dados dinamicos que estão dentro de um array.</p>
<h2>Links úteis</h2>
<p>Se quiserem ver mais exemplos e se aprofundar mais, vejam esses links.</p>
<ul>
<li>O <a href="https://ponyfoo.com/">blog</a> (ponyfoo) e <a href="https://ponyfoo.com/articles/es6-promises-in-depth">esse artigo</a> do <a href="https://twitter.com/nzgb">Nicolás Bevacqua</a> que são sensacionais.</li>
<li>Esse <a href="http://www.html5rocks.com/en/tutorials/es6/promises">artigo</a> do <a href="https://twitter.com/jaffathecake">Jake Archibald</a> é excelente.</li>
<li><a href="https://developer.mozilla.org">MDN</a> é vida, e é claro que tem <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise">documentação</a> sobre Promise.</li>
</ul>
<p>Bom galera, é isso.</p>
<p>Promises são ótimas, espero que com esse post vocês consigam entender melhor como é o seu funcionamento e usa-las no dia a dia.</p>
<p>Comentem ai o que acharam :)</p>
</div></article><section class="share"><svg xmlns="http://www.w3.org/2000/svg" display="none" version="1.1"><defs><symbol id="icon-twitter" viewBox="0 0 951 1024"><path class="path1" d="M925.714 233.143q-38.286 56-92.571 95.429 0.571 8 0.571 24 0 74.286-21.714 148.286t-66 142-105.429 120.286-147.429 83.429-184.571 31.143q-154.857 0-283.429-82.857 20 2.286 44.571 2.286 128.571 0 229.143-78.857-60-1.143-107.429-36.857t-65.143-91.143q18.857 2.857 34.857 2.857 24.571 0 48.571-6.286-64-13.143-106-63.714t-42-117.429v-2.286q38.857 21.714 83.429 23.429-37.714-25.143-60-65.714t-22.286-88q0-50.286 25.143-93.143 69.143 85.143 168.286 136.286t212.286 56.857q-4.571-21.714-4.571-42.286 0-76.571 54-130.571t130.571-54q80 0 134.857 58.286 62.286-12 117.143-44.571-21.143 65.714-81.143 101.714 53.143-5.714 106.286-28.571z"></path></symbol><symbol id="icon-facebook" viewBox="0 0 585 1024"><path class="path1" d="M548 6.857v150.857h-89.714q-49.143 0-66.286 20.571t-17.143 61.714v108h167.429l-22.286 169.143h-145.143v433.714h-174.857v-433.714h-145.714v-169.143h145.714v-124.571q0-106.286 59.429-164.857t158.286-58.571q84 0 130.286 6.857z"></path></symbol><symbol id="icon-google-plus" viewBox="0 0 951 1024"><path class="path1" d="M420 454.857q0 20.571 18.286 40.286t44.286 38.857 51.714 42 44 59.429 18.286 81.143q0 51.429-27.429 98.857-41.143 69.714-120.571 102.571t-170.286 32.857q-75.429 0-140.857-23.714t-98-78.571q-21.143-34.286-21.143-74.857 0-46.286 25.429-85.714t67.714-65.714q74.857-46.857 230.857-57.143-18.286-24-27.143-42.286t-8.857-41.714q0-20.571 12-48.571-26.286 2.286-38.857 2.286-84.571 0-142.571-55.143t-58-139.714q0-46.857 20.571-90.857t56.571-74.857q44-37.714 104.286-56t124.286-18.286h238.857l-78.857 50.286h-74.857q42.286 36 64 76t21.714 91.429q0 41.143-14 74t-33.714 53.143-39.714 37.143-34 35.143-14 37.714zM336.571 400q21.714 0 44.571-9.429t37.714-24.857q30.286-32.571 30.286-90.857 0-33.143-9.714-71.429t-27.714-74-48.286-59.143-66.857-23.429q-24 0-47.143 11.143t-37.429 30q-26.857 33.714-26.857 91.429 0 26.286 5.714 55.714t18 58.857 29.714 52.857 42.857 38.286 55.143 14.857zM337.714 898.857q33.143 0 63.714-7.429t56.571-22.286 41.714-41.714 15.714-62.286q0-14.286-4-28t-8.286-24-15.429-23.714-16.857-20-22-19.714-20.857-16.571-23.714-17.143-20.857-14.857q-9.143-1.143-27.429-1.143-30.286 0-60 4t-61.429 14.286-55.429 26.286-39.143 42.571-15.429 60.286q0 40 20 70.571t52.286 47.429 68 25.143 72.857 8.286zM800.571 398.286h121.714v61.714h-121.714v125.143h-60v-125.143h-121.143v-61.714h121.143v-124h60v124z"></path></symbol><symbol id="icon-angle-down" viewBox="0 0 658 1024"><path class="path1" d="M614.286 420.571q0 7.429-5.714 13.143l-266.286 266.286q-5.714 5.714-13.143 5.714t-13.143-5.714l-266.286-266.286q-5.714-5.714-5.714-13.143t5.714-13.143l28.571-28.571q5.714-5.714 13.143-5.714t13.143 5.714l224.571 224.571 224.571-224.571q5.714-5.714 13.143-5.714t13.143 5.714l28.571 28.571q5.714 5.714 5.714 13.143z"></path></symbol></defs></svg><a aria-label="Share on Twitter" href="https://twitter.com/intent/tweet?text=&quot;Entenda ES6 promises e suas vantagens em operações assíncronas no javascript.&quot; http://nipher.io/es6-promises via @nipher_jonas&amp;hashtags=es6,js,promises,async" title="Share on Twitter"><svg class="icon icon-twitter"><use href="#icon-twitter"></use></svg></a><a aria-label="Share on Facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://nipher.io/es6-promises" title="Share on Facebook"><svg class="icon icon-facebook"><use href="#icon-facebook"></use></svg></a><a aria-label="Share on Google Plus" href="https://plus.google.com/share?url=http://nipher.io/es6-promises" title="Share on Google+"><svg class="icon icon-google-plus"><use href="#icon-google-plus"></use></svg></a></section><div><div id="disqus_thread"></div></div></section></div><div style="width:100%;height:100%"></div></div></div><div id="__next-error"></div><script>
          __NEXT_DATA__ = {"props":{"pageProps":{"date":"08 Apr 2016","post":"\u003cp\u003eE ai galera, vamos continuar a série \u0026quot;ES6 - O que mudou?\u0026quot; :)\u003c/p\u003e\n\u003cp\u003eEsse post será sobre promises\u003c/p\u003e\n\u003cp\u003eLista dos tópicos que irei abordar:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eO que é uma Promise?\u003c/li\u003e\n\u003cli\u003eStates\u003c/li\u003e\n\u003cli\u003eConstructor\u003c/li\u003e\n\u003cli\u003eInstance Methods\u003c/li\u003e\n\u003cli\u003eStatic Methods\u003c/li\u003e\n\u003cli\u003eChaining\u003c/li\u003e\n\u003cli\u003eError handling\u003c/li\u003e\n\u003cli\u003eParallelism and sequencing\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eVamos começar\u003c/p\u003e\n\u003ch2\u003eO que é uma Promise?\u003c/h2\u003e\n\u003cp\u003ePromise é um objeto usado para representar uma operação que ainda não foi completada, mas que eventualmente será finalizada no futuro.\u003c/p\u003e\n\u003cp\u003eEsse objeto tem uma API que te permite fazer algo assim que ela acabar, recebendo o resultado dessa operação como parâmetro.\u003c/p\u003e\n\u003cp\u003e\u0026quot;Ta, mas eu já faço isso com callback\u0026quot;\u003c/p\u003e\n\u003cp\u003eUsar promises tem diversas vantagens, ela te permite manipular o resultado de uma ou várias operações assíncronas com mais facilidade e organização.\n\u003cstrong\u003ePromise é uma das soluções para o callback hell.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eEntão, vamos ver um pequeno exemplo utilizando uma callback comum, para relembrar como fazemos operações assíncronas sem promises.\u003c/p\u003e\n\u003cp\u003eDigamos que nós temos uma função \u003ccode\u003efetch\u003c/code\u003e que faz requests HTTP para um servidor.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efetch(\u003cspan class=\"hljs-string\"\u003e'/data.json'\u003c/span\u003e, (err, data) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (err) {\n    \u003cspan class=\"hljs-comment\"\u003e// handle error\u003c/span\u003e\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// handle data from server\u003c/span\u003e\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOk, temos uma callback que recebe 2 parâmetros, um \u003ccode\u003eerr\u003c/code\u003e (caso tenha ocorrido algum erro) e um \u003ccode\u003edata\u003c/code\u003e (dados que o servidor retornou para a nossa aplicação).\u003c/p\u003e\n\u003cp\u003eAgora vamos ver como fazemos a mesma operação, sendo que a função \u003ccode\u003efetch\u003c/code\u003e irá retornar uma promise dessa vez.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efetch(\u003cspan class=\"hljs-string\"\u003e'/data.json'\u003c/span\u003e)\n  .then(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// handle data from server\u003c/span\u003e\n  })\n  .catch(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eerr\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// handle error\u003c/span\u003e\n  });\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDessa vez, chamamos 2 métodos, o \u003ccode\u003ethen\u003c/code\u003e (que é chamado recebendo o dado do backend caso tudo tenha dado certo) e o \u003ccode\u003ecatch\u003c/code\u003e (que é chamado recebendo um erro caso algo tenha dado errado), falarei mais sobre eles ao decorrer do post.\u003c/p\u003e\n\u003ch2\u003eStates\u003c/h2\u003e\n\u003cp\u003eUma promise só pode ter 3 possíveis estados:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePending\u003c/li\u003e\n\u003cli\u003eFulfilled\u003c/li\u003e\n\u003cli\u003eRejected\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePendente, resolvida ou rejeitada.\u003c/p\u003e\n\u003cp\u003eCaso o status atual seja pendente, a operação ainda não acabou e nenhuma callback passada para os métodos \u003ccode\u003ethen\u003c/code\u003e ou \u003ccode\u003ecatch\u003c/code\u003e foi invocada ainda.\u003c/p\u003e\n\u003cp\u003eSe resolvida, o valor recebido é o valor que a operação retorna, quando a operação for executada sem problemas (parâmetro recebido no \u003ccode\u003ethen\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eSe rejeitada, o valor é uma informação de erro, avisando que algo deu errado na operação e descrevendo a razão do acontecido (parâmetro recebido no \u003ccode\u003ecatch\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eUma promise não pode ser resolvida e em seguida rejeitada ou vice e versa\u003c/strong\u003e, a única transição de estado que ela sofre, é de pendente para uma das duas (resolvida ou rejeitada).\u003c/p\u003e\n\u003ch2\u003eConstructor\u003c/h2\u003e\n\u003cp\u003eEntão, qual é a sintaxe usada para criarmos uma promise em ES6?\u003c/p\u003e\n\u003cp\u003ePara criarmos uma instância de uma Promise, vamos usar o construtor \u003ccode\u003ePromise(..)\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eComo exemplo, vamos ver uma representação do que acontece dentro da função \u003ccode\u003efetch\u003c/code\u003e, que foi usada anteriormente.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003efetch\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eurl\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresolve , reject\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// Faz o request HTTP (assíncrono)\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// dentro da callback do request chama `resolve(..)` ou `reject(..)`\u003c/span\u003e\n  }); \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNo código acima, dentro da função \u003ccode\u003efetch\u003c/code\u003e estamos retornando uma nova Promise, criada por nós. O construtor dessa Promise, recebe uma função como parâmetro e essa função recebe dois parâmetros (\u003ccode\u003eresolve\u003c/code\u003e e \u003ccode\u003ereject\u003c/code\u003e), que também são funções.\u003c/p\u003e\n\u003cp\u003eEntão, quando queremos que a nossa promise, seja resolvida, chamamos a função que recebemos como parâmetro \u003ccode\u003eresolve('Some data')\u003c/code\u003e, e no caso de erro, chamamos o \u003ccode\u003ereject('Error description')\u003c/code\u003e que também recebemos como parâmetro.\u003c/p\u003e\n\u003cp\u003eVamos implementar um \u003ccode\u003efetch\u003c/code\u003e falso que chamaria \u003ccode\u003eresolve\u003c/code\u003e depois de uma operação assíncrona, no exemplo usaremos o \u003ccode\u003esetTimeout\u003c/code\u003e para simular algo assíncrono.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003efetch\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eurl\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresolve , reject\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    setTimeout(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e resolve(\u003cspan class=\"hljs-string\"\u003e'Some data'\u003c/span\u003e), \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n  }); \n}\n\nfetch(\u003cspan class=\"hljs-string\"\u003e'/some-url'\u003c/span\u003e)\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(data));\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'Some data'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eComo podemos ver no exemplo, a callback passada para o método \u003ccode\u003ethen\u003c/code\u003e recebe o dado \u003ccode\u003e'Some data'\u003c/code\u003e, que é a string que passamos para a função \u003ccode\u003eresolve\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAgora vamos ver um exemplo parecido, mas dessa vez chamaremos a função \u003ccode\u003ereject\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003efetch\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eurl\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresolve , reject\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    setTimeout(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e reject(\u003cspan class=\"hljs-built_in\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Something went wrong'\u003c/span\u003e)), \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n  }); \n}\n\nfetch(\u003cspan class=\"hljs-string\"\u003e'/some-url'\u003c/span\u003e)\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(data))\n  .catch(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eerr\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(err));\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; Error: Something went wrong\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNesse exemplo, vemos a callback passada para o método \u003ccode\u003ecatch\u003c/code\u003e sendo executada recebendo o dado \u003ccode\u003e'Something went wrong'\u003c/code\u003e como o parâmetro \u003ccode\u003eerr\u003c/code\u003e.\nAlgo importante a citar, é que o \u003ccode\u003ethen\u003c/code\u003e \u003cstrong\u003enão é executado\u003c/strong\u003e nesse caso, porque quando o \u003ccode\u003ereject\u003c/code\u003e é chamado, ele pula para o primeiro \u003ccode\u003ecatch\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eInstance Methods\u003c/h2\u003e\n\u003cp\u003eOs métodos de uma instância de \u003ccode\u003ePromise\u003c/code\u003e, são o \u003ccode\u003ethen\u003c/code\u003e e o \u003ccode\u003ecatch\u003c/code\u003e.\u003c/p\u003e\n\u003ch4\u003ethen(..)\u003c/h4\u003e\n\u003cp\u003eO método \u003ccode\u003ethen\u003c/code\u003e, recebe uma callback de sucesso que será executada quando a promise for resolvida e uma segunda callback que será executada quando a promise for rejeitada.\u003c/p\u003e\n\u003cp\u003eExemplo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003efetch\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eurl\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresolve , reject\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    setTimeout(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e reject(\u003cspan class=\"hljs-built_in\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Something went wrong'\u003c/span\u003e)), \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n  }); \n}\n\nfetch(\u003cspan class=\"hljs-string\"\u003e'/some-url'\u003c/span\u003e)\n  .then(\n    \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(data),\n    err =\u0026gt; \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(err)\n  );\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; Error: Something went wrong\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNo exemplo acima, ao invés de usarmos \u003ccode\u003ecatch\u003c/code\u003e passamos a callback de erro como o segundo parâmetro do \u003ccode\u003ethen\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eNo final das contas, não faz diferença entre fazer dessa forma ou usar o \u003ccode\u003ecatch\u003c/code\u003e, eu pessoalmente gosto de usar o \u003ccode\u003ecatch\u003c/code\u003e, acho que fica mais claro e organizado.\u003c/p\u003e\n\u003ch4\u003ecatch(..)\u003c/h4\u003e\n\u003cp\u003eComo visto nos exemplos anteriores, o método \u003ccode\u003ecatch\u003c/code\u003e recebe uma única callback, para tratar de um erro que possa ter ocorrido na operação, quando a promise é rejeitada.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eEsses dois métodos retornam uma promise.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u0026quot;Oi? o.O\u0026quot;\u003c/p\u003e\n\u003cp\u003eIsso mesmo, como você já deve ter reparado nos exemplos, o \u003ccode\u003ecatch\u003c/code\u003e está sendo chamado logo após o \u003ccode\u003ethen\u003c/code\u003e, ou seja, é executado o método \u003ccode\u003ecatch\u003c/code\u003e do retorno do \u003ccode\u003ethen\u003c/code\u003e, isso funciona porque eles retornam uma promise.\u003c/p\u003e\n\u003cp\u003e\u0026quot;Então quer dizer que eu posso chamar o método \u003ccode\u003ethen\u003c/code\u003e depois do \u003ccode\u003ecatch\u003c/code\u003e também?\u0026quot;\u003c/p\u003e\n\u003cp\u003eIsso mesmo, podemos até chamar \u003ccode\u003ethen\u003c/code\u003e depois de \u003ccode\u003ethen\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eMostrarei como isso faz sentido no tópico \u0026quot;chaining\u0026quot;.\u003c/p\u003e\n\u003ch2\u003eStatic Methods\u003c/h2\u003e\n\u003cp\u003eAssim como podemos criar promises \u003ccode\u003enew Promise((resolve, reject) =\u0026gt; { .. })\u003c/code\u003e podemos também chamar métodos estáticos dessa referência (\u003ccode\u003ePromise\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eTemos alguns métodos que podemos usar, que são bem úteis.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eall(iterable)\u003c/li\u003e\n\u003cli\u003erace(iterable)\u003c/li\u003e\n\u003cli\u003eresolve(value)\u003c/li\u003e\n\u003cli\u003ereject(reason)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003eall([..])\u003c/h4\u003e\n\u003cp\u003eO método \u003ccode\u003ePromise.all(..)\u003c/code\u003e recebe como parâmetro um array contendo promises e retorna uma promise que ou será resolvida apenas quando \u003cstrong\u003etodas\u003c/strong\u003e as promises do array estiverem resolvidas ou rejeitada assim que \u003cstrong\u003euma\u003c/strong\u003e delas for rejeitada.\u003c/p\u003e\n\u003cp\u003eVamos ver um exemplo sem \u003ccode\u003ecatch\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e promises = [];\n\npromises.push(fetch(\u003cspan class=\"hljs-string\"\u003e'/some-url/1'\u003c/span\u003e));\npromises.push(fetch(\u003cspan class=\"hljs-string\"\u003e'/some-url/2'\u003c/span\u003e));\npromises.push(fetch(\u003cspan class=\"hljs-string\"\u003e'/some-url/3'\u003c/span\u003e));\n\n\u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.all(promises)\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresponses\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(responses));\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; ['Some data 1  ', 'Some data 2', 'Some data 3']\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEntão, recapitulando o que aconteceu acima\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eChamamos a nossa função \u003ccode\u003efetch\u003c/code\u003e 3 vezes, para cada chamada é retornado uma promise diferente e adicionamos a promise retornada em um array.\u003c/li\u003e\n\u003cli\u003eAcessamos o método estático \u003ccode\u003eall\u003c/code\u003e da referência global \u003ccode\u003ePromise\u003c/code\u003e e passamos o array (\u003ccode\u003epromises\u003c/code\u003e) como parâmetro.\u003c/li\u003e\n\u003cli\u003eComo o método \u003ccode\u003eall\u003c/code\u003e retorna uma promise, estamos dando um \u003ccode\u003ethen\u003c/code\u003e logo em seguida do \u003ccode\u003eall\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eA callback que passamos para o \u003ccode\u003ethen\u003c/code\u003e está recebendo um array de resultados, os resultados estão na mesma ordem das promises que existem dentro do array, logo \u003ccode\u003eresponses[0]\u003c/code\u003e seria a resposta de \u003ccode\u003epromises[0]\u003c/code\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eVamos ver um exemplo igual, mas com uma das promises sendo rejeitada.\u003c/p\u003e\n\u003cp\u003eDigamos que nesse exemplo, quando chamamos o \u003ccode\u003efetch\u003c/code\u003e com \u003ccode\u003e/some-url/2\u003c/code\u003e a promise retornada seja rejeitada, teriamos um array de 2 promises que serão resolvidas e 1 rejeitada. Vamos ver o que acontece.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e promises = [];\n\npromises.push(fetch(\u003cspan class=\"hljs-string\"\u003e'/some-url/1'\u003c/span\u003e));\npromises.push(fetch(\u003cspan class=\"hljs-string\"\u003e'/some-url/2'\u003c/span\u003e));\npromises.push(fetch(\u003cspan class=\"hljs-string\"\u003e'/some-url/3'\u003c/span\u003e));\n\n\u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.all(promises)\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresponses\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(responses))\n  .catch(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eerr\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(err));\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; Error: Something went wrong\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEntão, aconteceu a mesma coisa quando temos uma promise rejeitada, o \u003ccode\u003ethen\u003c/code\u003e foi ignorado, e fomos parar direto no \u003ccode\u003ecatch\u003c/code\u003e com apenas uma mensagem de erro que veio da segunda promise do array.\u003c/p\u003e\n\u003cp\u003eVale citar que as outras operações ainda serão executadas, elas não são abortadas, porém, a callback do \u003ccode\u003ethen\u003c/code\u003e mesmo assim não será chamada.\u003c/p\u003e\n\u003ch4\u003erace([..])\u003c/h4\u003e\n\u003cp\u003eO método \u003ccode\u003ePromise.race(..)\u003c/code\u003e também recebe como parâmetro um array contendo promises e retorna uma promise que ou será resolvida assim que \u003cstrong\u003equalquer uma\u003c/strong\u003e das promises do array estiverem resolvida ou rejeitada assim que \u003cstrong\u003equalquer uma\u003c/strong\u003e delas for rejeitada.\u003c/p\u003e\n\u003cp\u003eVamos ver um exemplo em que a segunda promise foi a primeira que foi resolvida:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e promises = [];\n\npromises.push(fetch(\u003cspan class=\"hljs-string\"\u003e'/some-url/1'\u003c/span\u003e));\npromises.push(fetch(\u003cspan class=\"hljs-string\"\u003e'/some-url/2'\u003c/span\u003e));\npromises.push(fetch(\u003cspan class=\"hljs-string\"\u003e'/some-url/3'\u003c/span\u003e));\n\n\u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.race(promises)\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(response))\n  .catch(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eerr\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(err));\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'Some data 2'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eO exemplo é muito similar com o do \u003ccode\u003ePromise.all([..])\u003c/code\u003e, a única difereça, é que estamos chamando o método \u003ccode\u003erace\u003c/code\u003e e em vez de recebermos um array de resultados na callback do then, estamos recebendo o resultado da promise que foi resolvida primeiro.\u003c/p\u003e\n\u003cp\u003eNo caso em que uma das promises for rejeitada, acontecerá a mesma coisa que aconteceu no exemplo do \u003ccode\u003ePromise.all([..])\u003c/code\u003e, a callback do \u003ccode\u003ethen\u003c/code\u003e não será executada, e teremos o erro da promise que foi rejeitada.\u003c/p\u003e\n\u003cp\u003eLembrando de novo, que não acontece nenhum tipo de cancelamento das outras operações, promises não tem um método para isso.\u003c/p\u003e\n\u003ch4\u003eresolve(..)\u003c/h4\u003e\n\u003cp\u003eEsse método é bem simples, ele retorna uma promise já resolvida, e recebe como parâmetro o valor que a callback do \u003ccode\u003ethen\u003c/code\u003e receberá.\u003c/p\u003e\n\u003cp\u003eExemplo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e promise = \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.resolve(\u003cspan class=\"hljs-string\"\u003e'My data'\u003c/span\u003e);\n\npromise\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(data));\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'My data'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003ereject(..)\u003c/h4\u003e\n\u003cp\u003eEsse método é o contrário do \u003ccode\u003ePromise.resolve(..)\u003c/code\u003e, ele retorna uma promise já rejeitada, e recebe como parâmetro o valor que a callback do \u003ccode\u003ecatch\u003c/code\u003e receberá (o motivo da rejeição).\u003c/p\u003e\n\u003cp\u003eExemplo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e promise = \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.reject(\u003cspan class=\"hljs-built_in\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Some reason'\u003c/span\u003e));\n\npromise\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(data))\n  .catch(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ereason\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(reason));\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; Error: Some reason\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eChaining\u003c/h2\u003e\n\u003cp\u003eEntão, lembram quando eu mencionei que podemos chamar \u003ccode\u003ethen\u003c/code\u003e / \u003ccode\u003ecatch\u003c/code\u003e seguido de outro \u003ccode\u003ethen\u003c/code\u003e / \u003ccode\u003ecatch\u003c/code\u003e?\u003c/p\u003e\n\u003cp\u003eIsso se chama chaining, nesse tópico vamos descobrir que \u003ccode\u003ethen\u003c/code\u003e não é o fim da estrada.\u003c/p\u003e\n\u003cp\u003ePodemos usar essa tática para processar dados ou executar mais operações assíncronas.\u003c/p\u003e\n\u003ch4\u003eProcessando dados\u003c/h4\u003e\n\u003cp\u003eVocê pode processar um dado que foi retornado em uma promise e continuar encadeamento de \u0026quot;thens\u0026quot;, simplesmente retornando um novo valor dentro da callback.\u003c/p\u003e\n\u003cp\u003eExemplo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e promise = \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.resolve(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n\npromise\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u0026gt;\u003c/span\u003e data + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(data));\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 3\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAcima, definimos uma promise já resolvida com o valor \u003ccode\u003e2\u003c/code\u003e, chamamos o método \u003ccode\u003ethen\u003c/code\u003e passando uma callback que retorna \u003ccode\u003edata + 1\u003c/code\u003e e em seguida colocamos mais um \u003ccode\u003ethen\u003c/code\u003e que loga seu \u003ccode\u003edata\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eO \u003ccode\u003edata\u003c/code\u003e do segundo \u003ccode\u003ethen\u003c/code\u003e é o retorno do primeiro.\u003c/p\u003e\n\u003cp\u003eEntão isso te permite criar um flow de execução bem limpo.\u003c/p\u003e\n\u003cp\u003eDigamos que chamamos o método \u003ccode\u003efetch\u003c/code\u003e pegando um json, mas esse json vem como string, e queremos transforma-lo em objeto.\u003c/p\u003e\n\u003cp\u003eExemplo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efetch(\u003cspan class=\"hljs-string\"\u003e'/data.json'\u003c/span\u003e)\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.parse(data))\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eobj\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(obj));\n\n\u0026gt; { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Promise'\u003c/span\u003e }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNesse exemplo, recebemos uma string \u003ccode\u003e'{ \u0026quot;name\u0026quot;: \u0026quot;Promise\u0026quot; }'\u003c/code\u003e, e transformamos ela em um objeto javascript chamando o método \u003ccode\u003eJSON.parse\u003c/code\u003e retornando o novo objeto para o próximo \u003ccode\u003ethen\u003c/code\u003e que apenas loga o objeto.\u003c/p\u003e\n\u003ch4\u003eExecutando mais operações assíncronas\u003c/h4\u003e\n\u003cp\u003eVocê pode encadear \u0026quot;thens\u0026quot; para executar mais operações assíncronas, em sequência da anterior.\u003c/p\u003e\n\u003cp\u003eQuando você retorna um valor na callback do \u003ccode\u003ethen\u003c/code\u003e a callback do próximo \u003ccode\u003ethen\u003c/code\u003e irá receber esse valor, mas se você retornar uma outra promise a próxima execução irá aguardar que essa promise seja resolvida ou rejeitada.\u003c/p\u003e\n\u003cp\u003eExemplo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efetch(\u003cspan class=\"hljs-string\"\u003e'/data.json'\u003c/span\u003e)\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.parse(data))\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eobj\u003c/span\u003e =\u0026gt;\u003c/span\u003e { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: obj.name, \u003cspan class=\"hljs-attr\"\u003edate\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eDate\u003c/span\u003e() })\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eobj\u003c/span\u003e =\u0026gt;\u003c/span\u003e fetch(\u003cspan class=\"hljs-string\"\u003e'/save'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'POST'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: obj }))\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(response));\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'Done.'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003col\u003e\n\u003cli\u003eUsamos o \u003ccode\u003efetch\u003c/code\u003e mais uma vez para fazer requests para uma API\u003c/li\u003e\n\u003cli\u003ePegamos um json da API\u003c/li\u003e\n\u003cli\u003eParseamos esse json\u003c/li\u003e\n\u003cli\u003eRetornamos um novo objeto com a propriedade \u003ccode\u003ename\u003c/code\u003e e com uma nova propriedade \u003ccode\u003edate\u003c/code\u003e recebendo a data atual\u003c/li\u003e\n\u003cli\u003eUsamos o fetch novamente passando esse novo objeto para outra rota da API\u003c/li\u003e\n\u003cli\u003eQuando o novo request acabar, o próximo \u003ccode\u003ethen\u003c/code\u003e será executado, e logamos a resposta.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eAgora, parem para pensar como isso ficaria sem promises...\u003c/p\u003e\n\u003cp\u003ePois é, quando disse que promise é uma das soluções para o callback hell, foi isso que eu quis dizer.\u003c/p\u003e\n\u003ch2\u003eError handling\u003c/h2\u003e\n\u003cp\u003eJá vimos a utilização do \u003ccode\u003ecatch\u003c/code\u003e em alguns exemplos, usaremos o \u003ccode\u003ecatch\u003c/code\u003e bastante para tratar os erros que acontecem nessas operações com promises.\u003c/p\u003e\n\u003cp\u003eA callback que passamos pro\u003ccode\u003ecatch\u003c/code\u003e será chamada caso a etapa anterior a ele der algum erro ou retornar uma promise rejeitada.\u003c/p\u003e\n\u003cp\u003eExemplo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.resolve(\u003cspan class=\"hljs-string\"\u003e'Data'\u003c/span\u003e)\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.reject(\u003cspan class=\"hljs-built_in\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Fail'\u003c/span\u003e)))\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e'yay'\u003c/span\u003e))\n  .catch(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eerr\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(err));\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; Error: Fail\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNo exemplo, temos uma promise que foi resolvida, mas ao \u003ccode\u003ethen\u003c/code\u003e ser executado, retornamos uma promise rejeitada, causando a execução do próximo \u003ccode\u003ecatch\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eCom isso, dentro de \u0026quot;thens\u0026quot; podemos fazer checagens e retornar uma promise rejeitada para forçar a entrada no próximo \u003ccode\u003ecatch\u003c/code\u003e, porque checamos que algo deu errado e no \u003ccode\u003ecatch\u003c/code\u003e tratamos esse erro.\u003c/p\u003e\n\u003cp\u003eO mesmo acontece quando um \u003ccode\u003ethrow\u003c/code\u003e ocorre dentro de alguma etapa.\u003c/p\u003e\n\u003cp\u003eExemplo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.resolve(\u003cspan class=\"hljs-string\"\u003e'Data'\u003c/span\u003e)\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.parse(data))\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e'yay'\u003c/span\u003e))\n  .catch(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eerr\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(err));\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; SyntaxError: Unexpected token D\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//       at Object.parse (native) ...\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNó código acima, quando executamos o método \u003ccode\u003eJSON.parse\u003c/code\u003e passando \u003ccode\u003edata\u003c/code\u003e como parâmetro ocorre um \u003ccode\u003ethrow SyntaxError(..)\u003c/code\u003e. O que causa a execução direta do \u003ccode\u003ecatch\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eComo podemos ver o \u003ccode\u003ethrow\u003c/code\u003e não saiu do escopo do nosso encadeamento, permitindo o tratamento do erro, exibindo uma mensagem para o usuário ou até mesmo corrigindo o problema, sem afetar o funcionamento da aplicação.\u003c/p\u003e\n\u003ch2\u003eParallelism and sequencing\u003c/h2\u003e\n\u003cp\u003ePor último, vou mostrar duas formas de executarmos operações assim dinamicamente, utilizando métodos que nós temos nativamente em um \u003ccode\u003eArray\u003c/code\u003e.\u003c/p\u003e\n\u003ch4\u003eParalellism\u003c/h4\u003e\n\u003cp\u003eImaginem que temos um array de itens que queremos salvar através de uma API, e queremos mandar salvar todos eles em paralelo e fazer algo assim que cada operação acabar.\u003c/p\u003e\n\u003cp\u003eExemplo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e items = [{ \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'es5'\u003c/span\u003e }, { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'es6'\u003c/span\u003e }, { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'es7'\u003c/span\u003e }, { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'es8'\u003c/span\u003e }];\n\nitems.forEach(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eitem\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n  fetch(\u003cspan class=\"hljs-string\"\u003e'/save'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'POST'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: obj })\n    .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(res));\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'es6 Done.'\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'es8 Done.'\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'es5 Done.'\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'es7 Done.'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNesse exemplo, podemos ver que não importa a ordem de finalização de nossas operações, queremos que a nossa callback seja executada assim que a operação acabar.\u003c/p\u003e\n\u003cp\u003eNo output do console, podemos ver que o es6 foi o primeiro a terminar, o es8 foi o segundo, es5 terceiro e es7 o quarto.\u003c/p\u003e\n\u003cp\u003eNão queremos que seja sequencial, na ordem que está no array, só queremos que todos sejam salvos em paralelo e que nossas callbacks sejam executadas assim que sua respectiva promise for resolvida.\u003c/p\u003e\n\u003ch4\u003eSequencing\u003c/h4\u003e\n\u003cp\u003eImaginem o mesmo array, a mesma operação, porém não queremos continuar salvando esses itens caso uma das operações falhe ou que queremos salva-los sequencialmente, na ordem que está no array.\u003c/p\u003e\n\u003cp\u003eExemplo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e items = [{ \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'es5'\u003c/span\u003e }, { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'es6'\u003c/span\u003e }, { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'es7'\u003c/span\u003e }, { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'es8'\u003c/span\u003e }];\n\nitems.reduce(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003esequence, obj\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e sequence\n    .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e fetch(\u003cspan class=\"hljs-string\"\u003e'/save'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'POST'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: obj }))\n    .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(res));\n}, \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.resolve());\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'es5 Done.'\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'es6 Done.'\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'es7 Done.'\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'es8 Done.'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNesse exemplo podemos ver que criamos um encadeamento dinamico, não importa a quantidade de itens que temos no array, todos eles serão salvos na ordem que estão no array.\u003c/p\u003e\n\u003cp\u003eO método reduce no final das contas, é a mesma coisa que esse código:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e items = [{ \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'es5'\u003c/span\u003e }, { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'es6'\u003c/span\u003e }, { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'es7'\u003c/span\u003e }, { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'es8'\u003c/span\u003e }];\n\n\u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.resolve()\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e fetch(\u003cspan class=\"hljs-string\"\u003e'/save'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'POST'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: items[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] }))\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(res))\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e fetch(\u003cspan class=\"hljs-string\"\u003e'/save'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'POST'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: items[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] }))\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(res))\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e fetch(\u003cspan class=\"hljs-string\"\u003e'/save'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'POST'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: items[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e] }))\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(res))\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e fetch(\u003cspan class=\"hljs-string\"\u003e'/save'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'POST'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: items[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e] }))\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(res));\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'es5 Done.'\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'es6 Done.'\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'es7 Done.'\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'es8 Done.'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePorém, com \u003ccode\u003ereduce\u003c/code\u003e, não importa a quantidade de items, conseguimos fazer operações baseadas em dados dinamicos que estão dentro de um array.\u003c/p\u003e\n\u003ch2\u003eLinks úteis\u003c/h2\u003e\n\u003cp\u003eSe quiserem ver mais exemplos e se aprofundar mais, vejam esses links.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eO \u003ca href=\"https://ponyfoo.com/\"\u003eblog\u003c/a\u003e (ponyfoo) e \u003ca href=\"https://ponyfoo.com/articles/es6-promises-in-depth\"\u003eesse artigo\u003c/a\u003e do \u003ca href=\"https://twitter.com/nzgb\"\u003eNicolás Bevacqua\u003c/a\u003e que são sensacionais.\u003c/li\u003e\n\u003cli\u003eEsse \u003ca href=\"http://www.html5rocks.com/en/tutorials/es6/promises\"\u003eartigo\u003c/a\u003e do \u003ca href=\"https://twitter.com/jaffathecake\"\u003eJake Archibald\u003c/a\u003e é excelente.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org\"\u003eMDN\u003c/a\u003e é vida, e é claro que tem \u003ca href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise\"\u003edocumentação\u003c/a\u003e sobre Promise.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBom galera, é isso.\u003c/p\u003e\n\u003cp\u003ePromises são ótimas, espero que com esse post vocês consigam entender melhor como é o seu funcionamento e usa-las no dia a dia.\u003c/p\u003e\n\u003cp\u003eComentem ai o que acharam :)\u003c/p\u003e\n","metaData":{"layout":"post","title":"ES6 - Promises","slug":"es6-promises","description":"Entenda ES6 promises e suas vantagens em operações assíncronas no javascript.","date":"2016-04-08 18:40:43 -0300","language":"Brazilian Portuguese","excerpt":"Esse post será sobre promises\n\nLista dos tópicos que irei abordar:\n\n- O que é uma Promise?\n- States\n- Constructor\n- Instance Methods\n- Static Methods\n- Chaining\n- Error handling\n- Parallelism and sequencing\n","tags":["es6","js","promises","async"],"categories":["ES6 - O que mudou?"]},"slug":"es6-promises","build":true}},"page":"/post","pathname":"/post","query":{"date":"08 Apr 2016","post":"\u003cp\u003eE ai galera, vamos continuar a série \u0026quot;ES6 - O que mudou?\u0026quot; :)\u003c/p\u003e\n\u003cp\u003eEsse post será sobre promises\u003c/p\u003e\n\u003cp\u003eLista dos tópicos que irei abordar:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eO que é uma Promise?\u003c/li\u003e\n\u003cli\u003eStates\u003c/li\u003e\n\u003cli\u003eConstructor\u003c/li\u003e\n\u003cli\u003eInstance Methods\u003c/li\u003e\n\u003cli\u003eStatic Methods\u003c/li\u003e\n\u003cli\u003eChaining\u003c/li\u003e\n\u003cli\u003eError handling\u003c/li\u003e\n\u003cli\u003eParallelism and sequencing\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eVamos começar\u003c/p\u003e\n\u003ch2\u003eO que é uma Promise?\u003c/h2\u003e\n\u003cp\u003ePromise é um objeto usado para representar uma operação que ainda não foi completada, mas que eventualmente será finalizada no futuro.\u003c/p\u003e\n\u003cp\u003eEsse objeto tem uma API que te permite fazer algo assim que ela acabar, recebendo o resultado dessa operação como parâmetro.\u003c/p\u003e\n\u003cp\u003e\u0026quot;Ta, mas eu já faço isso com callback\u0026quot;\u003c/p\u003e\n\u003cp\u003eUsar promises tem diversas vantagens, ela te permite manipular o resultado de uma ou várias operações assíncronas com mais facilidade e organização.\n\u003cstrong\u003ePromise é uma das soluções para o callback hell.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eEntão, vamos ver um pequeno exemplo utilizando uma callback comum, para relembrar como fazemos operações assíncronas sem promises.\u003c/p\u003e\n\u003cp\u003eDigamos que nós temos uma função \u003ccode\u003efetch\u003c/code\u003e que faz requests HTTP para um servidor.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efetch(\u003cspan class=\"hljs-string\"\u003e'/data.json'\u003c/span\u003e, (err, data) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (err) {\n    \u003cspan class=\"hljs-comment\"\u003e// handle error\u003c/span\u003e\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// handle data from server\u003c/span\u003e\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOk, temos uma callback que recebe 2 parâmetros, um \u003ccode\u003eerr\u003c/code\u003e (caso tenha ocorrido algum erro) e um \u003ccode\u003edata\u003c/code\u003e (dados que o servidor retornou para a nossa aplicação).\u003c/p\u003e\n\u003cp\u003eAgora vamos ver como fazemos a mesma operação, sendo que a função \u003ccode\u003efetch\u003c/code\u003e irá retornar uma promise dessa vez.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efetch(\u003cspan class=\"hljs-string\"\u003e'/data.json'\u003c/span\u003e)\n  .then(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// handle data from server\u003c/span\u003e\n  })\n  .catch(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eerr\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// handle error\u003c/span\u003e\n  });\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDessa vez, chamamos 2 métodos, o \u003ccode\u003ethen\u003c/code\u003e (que é chamado recebendo o dado do backend caso tudo tenha dado certo) e o \u003ccode\u003ecatch\u003c/code\u003e (que é chamado recebendo um erro caso algo tenha dado errado), falarei mais sobre eles ao decorrer do post.\u003c/p\u003e\n\u003ch2\u003eStates\u003c/h2\u003e\n\u003cp\u003eUma promise só pode ter 3 possíveis estados:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePending\u003c/li\u003e\n\u003cli\u003eFulfilled\u003c/li\u003e\n\u003cli\u003eRejected\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePendente, resolvida ou rejeitada.\u003c/p\u003e\n\u003cp\u003eCaso o status atual seja pendente, a operação ainda não acabou e nenhuma callback passada para os métodos \u003ccode\u003ethen\u003c/code\u003e ou \u003ccode\u003ecatch\u003c/code\u003e foi invocada ainda.\u003c/p\u003e\n\u003cp\u003eSe resolvida, o valor recebido é o valor que a operação retorna, quando a operação for executada sem problemas (parâmetro recebido no \u003ccode\u003ethen\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eSe rejeitada, o valor é uma informação de erro, avisando que algo deu errado na operação e descrevendo a razão do acontecido (parâmetro recebido no \u003ccode\u003ecatch\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eUma promise não pode ser resolvida e em seguida rejeitada ou vice e versa\u003c/strong\u003e, a única transição de estado que ela sofre, é de pendente para uma das duas (resolvida ou rejeitada).\u003c/p\u003e\n\u003ch2\u003eConstructor\u003c/h2\u003e\n\u003cp\u003eEntão, qual é a sintaxe usada para criarmos uma promise em ES6?\u003c/p\u003e\n\u003cp\u003ePara criarmos uma instância de uma Promise, vamos usar o construtor \u003ccode\u003ePromise(..)\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eComo exemplo, vamos ver uma representação do que acontece dentro da função \u003ccode\u003efetch\u003c/code\u003e, que foi usada anteriormente.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003efetch\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eurl\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresolve , reject\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// Faz o request HTTP (assíncrono)\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// dentro da callback do request chama `resolve(..)` ou `reject(..)`\u003c/span\u003e\n  }); \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNo código acima, dentro da função \u003ccode\u003efetch\u003c/code\u003e estamos retornando uma nova Promise, criada por nós. O construtor dessa Promise, recebe uma função como parâmetro e essa função recebe dois parâmetros (\u003ccode\u003eresolve\u003c/code\u003e e \u003ccode\u003ereject\u003c/code\u003e), que também são funções.\u003c/p\u003e\n\u003cp\u003eEntão, quando queremos que a nossa promise, seja resolvida, chamamos a função que recebemos como parâmetro \u003ccode\u003eresolve('Some data')\u003c/code\u003e, e no caso de erro, chamamos o \u003ccode\u003ereject('Error description')\u003c/code\u003e que também recebemos como parâmetro.\u003c/p\u003e\n\u003cp\u003eVamos implementar um \u003ccode\u003efetch\u003c/code\u003e falso que chamaria \u003ccode\u003eresolve\u003c/code\u003e depois de uma operação assíncrona, no exemplo usaremos o \u003ccode\u003esetTimeout\u003c/code\u003e para simular algo assíncrono.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003efetch\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eurl\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresolve , reject\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    setTimeout(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e resolve(\u003cspan class=\"hljs-string\"\u003e'Some data'\u003c/span\u003e), \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n  }); \n}\n\nfetch(\u003cspan class=\"hljs-string\"\u003e'/some-url'\u003c/span\u003e)\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(data));\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'Some data'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eComo podemos ver no exemplo, a callback passada para o método \u003ccode\u003ethen\u003c/code\u003e recebe o dado \u003ccode\u003e'Some data'\u003c/code\u003e, que é a string que passamos para a função \u003ccode\u003eresolve\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAgora vamos ver um exemplo parecido, mas dessa vez chamaremos a função \u003ccode\u003ereject\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003efetch\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eurl\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresolve , reject\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    setTimeout(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e reject(\u003cspan class=\"hljs-built_in\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Something went wrong'\u003c/span\u003e)), \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n  }); \n}\n\nfetch(\u003cspan class=\"hljs-string\"\u003e'/some-url'\u003c/span\u003e)\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(data))\n  .catch(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eerr\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(err));\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; Error: Something went wrong\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNesse exemplo, vemos a callback passada para o método \u003ccode\u003ecatch\u003c/code\u003e sendo executada recebendo o dado \u003ccode\u003e'Something went wrong'\u003c/code\u003e como o parâmetro \u003ccode\u003eerr\u003c/code\u003e.\nAlgo importante a citar, é que o \u003ccode\u003ethen\u003c/code\u003e \u003cstrong\u003enão é executado\u003c/strong\u003e nesse caso, porque quando o \u003ccode\u003ereject\u003c/code\u003e é chamado, ele pula para o primeiro \u003ccode\u003ecatch\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eInstance Methods\u003c/h2\u003e\n\u003cp\u003eOs métodos de uma instância de \u003ccode\u003ePromise\u003c/code\u003e, são o \u003ccode\u003ethen\u003c/code\u003e e o \u003ccode\u003ecatch\u003c/code\u003e.\u003c/p\u003e\n\u003ch4\u003ethen(..)\u003c/h4\u003e\n\u003cp\u003eO método \u003ccode\u003ethen\u003c/code\u003e, recebe uma callback de sucesso que será executada quando a promise for resolvida e uma segunda callback que será executada quando a promise for rejeitada.\u003c/p\u003e\n\u003cp\u003eExemplo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003efetch\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eurl\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresolve , reject\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    setTimeout(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e reject(\u003cspan class=\"hljs-built_in\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Something went wrong'\u003c/span\u003e)), \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n  }); \n}\n\nfetch(\u003cspan class=\"hljs-string\"\u003e'/some-url'\u003c/span\u003e)\n  .then(\n    \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(data),\n    err =\u0026gt; \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(err)\n  );\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; Error: Something went wrong\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNo exemplo acima, ao invés de usarmos \u003ccode\u003ecatch\u003c/code\u003e passamos a callback de erro como o segundo parâmetro do \u003ccode\u003ethen\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eNo final das contas, não faz diferença entre fazer dessa forma ou usar o \u003ccode\u003ecatch\u003c/code\u003e, eu pessoalmente gosto de usar o \u003ccode\u003ecatch\u003c/code\u003e, acho que fica mais claro e organizado.\u003c/p\u003e\n\u003ch4\u003ecatch(..)\u003c/h4\u003e\n\u003cp\u003eComo visto nos exemplos anteriores, o método \u003ccode\u003ecatch\u003c/code\u003e recebe uma única callback, para tratar de um erro que possa ter ocorrido na operação, quando a promise é rejeitada.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eEsses dois métodos retornam uma promise.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u0026quot;Oi? o.O\u0026quot;\u003c/p\u003e\n\u003cp\u003eIsso mesmo, como você já deve ter reparado nos exemplos, o \u003ccode\u003ecatch\u003c/code\u003e está sendo chamado logo após o \u003ccode\u003ethen\u003c/code\u003e, ou seja, é executado o método \u003ccode\u003ecatch\u003c/code\u003e do retorno do \u003ccode\u003ethen\u003c/code\u003e, isso funciona porque eles retornam uma promise.\u003c/p\u003e\n\u003cp\u003e\u0026quot;Então quer dizer que eu posso chamar o método \u003ccode\u003ethen\u003c/code\u003e depois do \u003ccode\u003ecatch\u003c/code\u003e também?\u0026quot;\u003c/p\u003e\n\u003cp\u003eIsso mesmo, podemos até chamar \u003ccode\u003ethen\u003c/code\u003e depois de \u003ccode\u003ethen\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eMostrarei como isso faz sentido no tópico \u0026quot;chaining\u0026quot;.\u003c/p\u003e\n\u003ch2\u003eStatic Methods\u003c/h2\u003e\n\u003cp\u003eAssim como podemos criar promises \u003ccode\u003enew Promise((resolve, reject) =\u0026gt; { .. })\u003c/code\u003e podemos também chamar métodos estáticos dessa referência (\u003ccode\u003ePromise\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eTemos alguns métodos que podemos usar, que são bem úteis.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eall(iterable)\u003c/li\u003e\n\u003cli\u003erace(iterable)\u003c/li\u003e\n\u003cli\u003eresolve(value)\u003c/li\u003e\n\u003cli\u003ereject(reason)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003eall([..])\u003c/h4\u003e\n\u003cp\u003eO método \u003ccode\u003ePromise.all(..)\u003c/code\u003e recebe como parâmetro um array contendo promises e retorna uma promise que ou será resolvida apenas quando \u003cstrong\u003etodas\u003c/strong\u003e as promises do array estiverem resolvidas ou rejeitada assim que \u003cstrong\u003euma\u003c/strong\u003e delas for rejeitada.\u003c/p\u003e\n\u003cp\u003eVamos ver um exemplo sem \u003ccode\u003ecatch\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e promises = [];\n\npromises.push(fetch(\u003cspan class=\"hljs-string\"\u003e'/some-url/1'\u003c/span\u003e));\npromises.push(fetch(\u003cspan class=\"hljs-string\"\u003e'/some-url/2'\u003c/span\u003e));\npromises.push(fetch(\u003cspan class=\"hljs-string\"\u003e'/some-url/3'\u003c/span\u003e));\n\n\u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.all(promises)\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresponses\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(responses));\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; ['Some data 1  ', 'Some data 2', 'Some data 3']\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEntão, recapitulando o que aconteceu acima\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eChamamos a nossa função \u003ccode\u003efetch\u003c/code\u003e 3 vezes, para cada chamada é retornado uma promise diferente e adicionamos a promise retornada em um array.\u003c/li\u003e\n\u003cli\u003eAcessamos o método estático \u003ccode\u003eall\u003c/code\u003e da referência global \u003ccode\u003ePromise\u003c/code\u003e e passamos o array (\u003ccode\u003epromises\u003c/code\u003e) como parâmetro.\u003c/li\u003e\n\u003cli\u003eComo o método \u003ccode\u003eall\u003c/code\u003e retorna uma promise, estamos dando um \u003ccode\u003ethen\u003c/code\u003e logo em seguida do \u003ccode\u003eall\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eA callback que passamos para o \u003ccode\u003ethen\u003c/code\u003e está recebendo um array de resultados, os resultados estão na mesma ordem das promises que existem dentro do array, logo \u003ccode\u003eresponses[0]\u003c/code\u003e seria a resposta de \u003ccode\u003epromises[0]\u003c/code\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eVamos ver um exemplo igual, mas com uma das promises sendo rejeitada.\u003c/p\u003e\n\u003cp\u003eDigamos que nesse exemplo, quando chamamos o \u003ccode\u003efetch\u003c/code\u003e com \u003ccode\u003e/some-url/2\u003c/code\u003e a promise retornada seja rejeitada, teriamos um array de 2 promises que serão resolvidas e 1 rejeitada. Vamos ver o que acontece.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e promises = [];\n\npromises.push(fetch(\u003cspan class=\"hljs-string\"\u003e'/some-url/1'\u003c/span\u003e));\npromises.push(fetch(\u003cspan class=\"hljs-string\"\u003e'/some-url/2'\u003c/span\u003e));\npromises.push(fetch(\u003cspan class=\"hljs-string\"\u003e'/some-url/3'\u003c/span\u003e));\n\n\u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.all(promises)\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresponses\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(responses))\n  .catch(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eerr\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(err));\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; Error: Something went wrong\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEntão, aconteceu a mesma coisa quando temos uma promise rejeitada, o \u003ccode\u003ethen\u003c/code\u003e foi ignorado, e fomos parar direto no \u003ccode\u003ecatch\u003c/code\u003e com apenas uma mensagem de erro que veio da segunda promise do array.\u003c/p\u003e\n\u003cp\u003eVale citar que as outras operações ainda serão executadas, elas não são abortadas, porém, a callback do \u003ccode\u003ethen\u003c/code\u003e mesmo assim não será chamada.\u003c/p\u003e\n\u003ch4\u003erace([..])\u003c/h4\u003e\n\u003cp\u003eO método \u003ccode\u003ePromise.race(..)\u003c/code\u003e também recebe como parâmetro um array contendo promises e retorna uma promise que ou será resolvida assim que \u003cstrong\u003equalquer uma\u003c/strong\u003e das promises do array estiverem resolvida ou rejeitada assim que \u003cstrong\u003equalquer uma\u003c/strong\u003e delas for rejeitada.\u003c/p\u003e\n\u003cp\u003eVamos ver um exemplo em que a segunda promise foi a primeira que foi resolvida:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e promises = [];\n\npromises.push(fetch(\u003cspan class=\"hljs-string\"\u003e'/some-url/1'\u003c/span\u003e));\npromises.push(fetch(\u003cspan class=\"hljs-string\"\u003e'/some-url/2'\u003c/span\u003e));\npromises.push(fetch(\u003cspan class=\"hljs-string\"\u003e'/some-url/3'\u003c/span\u003e));\n\n\u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.race(promises)\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(response))\n  .catch(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eerr\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(err));\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'Some data 2'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eO exemplo é muito similar com o do \u003ccode\u003ePromise.all([..])\u003c/code\u003e, a única difereça, é que estamos chamando o método \u003ccode\u003erace\u003c/code\u003e e em vez de recebermos um array de resultados na callback do then, estamos recebendo o resultado da promise que foi resolvida primeiro.\u003c/p\u003e\n\u003cp\u003eNo caso em que uma das promises for rejeitada, acontecerá a mesma coisa que aconteceu no exemplo do \u003ccode\u003ePromise.all([..])\u003c/code\u003e, a callback do \u003ccode\u003ethen\u003c/code\u003e não será executada, e teremos o erro da promise que foi rejeitada.\u003c/p\u003e\n\u003cp\u003eLembrando de novo, que não acontece nenhum tipo de cancelamento das outras operações, promises não tem um método para isso.\u003c/p\u003e\n\u003ch4\u003eresolve(..)\u003c/h4\u003e\n\u003cp\u003eEsse método é bem simples, ele retorna uma promise já resolvida, e recebe como parâmetro o valor que a callback do \u003ccode\u003ethen\u003c/code\u003e receberá.\u003c/p\u003e\n\u003cp\u003eExemplo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e promise = \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.resolve(\u003cspan class=\"hljs-string\"\u003e'My data'\u003c/span\u003e);\n\npromise\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(data));\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'My data'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003ereject(..)\u003c/h4\u003e\n\u003cp\u003eEsse método é o contrário do \u003ccode\u003ePromise.resolve(..)\u003c/code\u003e, ele retorna uma promise já rejeitada, e recebe como parâmetro o valor que a callback do \u003ccode\u003ecatch\u003c/code\u003e receberá (o motivo da rejeição).\u003c/p\u003e\n\u003cp\u003eExemplo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e promise = \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.reject(\u003cspan class=\"hljs-built_in\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Some reason'\u003c/span\u003e));\n\npromise\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(data))\n  .catch(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ereason\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(reason));\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; Error: Some reason\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eChaining\u003c/h2\u003e\n\u003cp\u003eEntão, lembram quando eu mencionei que podemos chamar \u003ccode\u003ethen\u003c/code\u003e / \u003ccode\u003ecatch\u003c/code\u003e seguido de outro \u003ccode\u003ethen\u003c/code\u003e / \u003ccode\u003ecatch\u003c/code\u003e?\u003c/p\u003e\n\u003cp\u003eIsso se chama chaining, nesse tópico vamos descobrir que \u003ccode\u003ethen\u003c/code\u003e não é o fim da estrada.\u003c/p\u003e\n\u003cp\u003ePodemos usar essa tática para processar dados ou executar mais operações assíncronas.\u003c/p\u003e\n\u003ch4\u003eProcessando dados\u003c/h4\u003e\n\u003cp\u003eVocê pode processar um dado que foi retornado em uma promise e continuar encadeamento de \u0026quot;thens\u0026quot;, simplesmente retornando um novo valor dentro da callback.\u003c/p\u003e\n\u003cp\u003eExemplo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e promise = \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.resolve(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n\npromise\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u0026gt;\u003c/span\u003e data + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(data));\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 3\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAcima, definimos uma promise já resolvida com o valor \u003ccode\u003e2\u003c/code\u003e, chamamos o método \u003ccode\u003ethen\u003c/code\u003e passando uma callback que retorna \u003ccode\u003edata + 1\u003c/code\u003e e em seguida colocamos mais um \u003ccode\u003ethen\u003c/code\u003e que loga seu \u003ccode\u003edata\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eO \u003ccode\u003edata\u003c/code\u003e do segundo \u003ccode\u003ethen\u003c/code\u003e é o retorno do primeiro.\u003c/p\u003e\n\u003cp\u003eEntão isso te permite criar um flow de execução bem limpo.\u003c/p\u003e\n\u003cp\u003eDigamos que chamamos o método \u003ccode\u003efetch\u003c/code\u003e pegando um json, mas esse json vem como string, e queremos transforma-lo em objeto.\u003c/p\u003e\n\u003cp\u003eExemplo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efetch(\u003cspan class=\"hljs-string\"\u003e'/data.json'\u003c/span\u003e)\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.parse(data))\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eobj\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(obj));\n\n\u0026gt; { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Promise'\u003c/span\u003e }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNesse exemplo, recebemos uma string \u003ccode\u003e'{ \u0026quot;name\u0026quot;: \u0026quot;Promise\u0026quot; }'\u003c/code\u003e, e transformamos ela em um objeto javascript chamando o método \u003ccode\u003eJSON.parse\u003c/code\u003e retornando o novo objeto para o próximo \u003ccode\u003ethen\u003c/code\u003e que apenas loga o objeto.\u003c/p\u003e\n\u003ch4\u003eExecutando mais operações assíncronas\u003c/h4\u003e\n\u003cp\u003eVocê pode encadear \u0026quot;thens\u0026quot; para executar mais operações assíncronas, em sequência da anterior.\u003c/p\u003e\n\u003cp\u003eQuando você retorna um valor na callback do \u003ccode\u003ethen\u003c/code\u003e a callback do próximo \u003ccode\u003ethen\u003c/code\u003e irá receber esse valor, mas se você retornar uma outra promise a próxima execução irá aguardar que essa promise seja resolvida ou rejeitada.\u003c/p\u003e\n\u003cp\u003eExemplo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efetch(\u003cspan class=\"hljs-string\"\u003e'/data.json'\u003c/span\u003e)\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.parse(data))\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eobj\u003c/span\u003e =\u0026gt;\u003c/span\u003e { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: obj.name, \u003cspan class=\"hljs-attr\"\u003edate\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eDate\u003c/span\u003e() })\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eobj\u003c/span\u003e =\u0026gt;\u003c/span\u003e fetch(\u003cspan class=\"hljs-string\"\u003e'/save'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'POST'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: obj }))\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(response));\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'Done.'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003col\u003e\n\u003cli\u003eUsamos o \u003ccode\u003efetch\u003c/code\u003e mais uma vez para fazer requests para uma API\u003c/li\u003e\n\u003cli\u003ePegamos um json da API\u003c/li\u003e\n\u003cli\u003eParseamos esse json\u003c/li\u003e\n\u003cli\u003eRetornamos um novo objeto com a propriedade \u003ccode\u003ename\u003c/code\u003e e com uma nova propriedade \u003ccode\u003edate\u003c/code\u003e recebendo a data atual\u003c/li\u003e\n\u003cli\u003eUsamos o fetch novamente passando esse novo objeto para outra rota da API\u003c/li\u003e\n\u003cli\u003eQuando o novo request acabar, o próximo \u003ccode\u003ethen\u003c/code\u003e será executado, e logamos a resposta.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eAgora, parem para pensar como isso ficaria sem promises...\u003c/p\u003e\n\u003cp\u003ePois é, quando disse que promise é uma das soluções para o callback hell, foi isso que eu quis dizer.\u003c/p\u003e\n\u003ch2\u003eError handling\u003c/h2\u003e\n\u003cp\u003eJá vimos a utilização do \u003ccode\u003ecatch\u003c/code\u003e em alguns exemplos, usaremos o \u003ccode\u003ecatch\u003c/code\u003e bastante para tratar os erros que acontecem nessas operações com promises.\u003c/p\u003e\n\u003cp\u003eA callback que passamos pro\u003ccode\u003ecatch\u003c/code\u003e será chamada caso a etapa anterior a ele der algum erro ou retornar uma promise rejeitada.\u003c/p\u003e\n\u003cp\u003eExemplo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.resolve(\u003cspan class=\"hljs-string\"\u003e'Data'\u003c/span\u003e)\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.reject(\u003cspan class=\"hljs-built_in\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Fail'\u003c/span\u003e)))\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e'yay'\u003c/span\u003e))\n  .catch(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eerr\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(err));\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; Error: Fail\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNo exemplo, temos uma promise que foi resolvida, mas ao \u003ccode\u003ethen\u003c/code\u003e ser executado, retornamos uma promise rejeitada, causando a execução do próximo \u003ccode\u003ecatch\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eCom isso, dentro de \u0026quot;thens\u0026quot; podemos fazer checagens e retornar uma promise rejeitada para forçar a entrada no próximo \u003ccode\u003ecatch\u003c/code\u003e, porque checamos que algo deu errado e no \u003ccode\u003ecatch\u003c/code\u003e tratamos esse erro.\u003c/p\u003e\n\u003cp\u003eO mesmo acontece quando um \u003ccode\u003ethrow\u003c/code\u003e ocorre dentro de alguma etapa.\u003c/p\u003e\n\u003cp\u003eExemplo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.resolve(\u003cspan class=\"hljs-string\"\u003e'Data'\u003c/span\u003e)\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.parse(data))\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e'yay'\u003c/span\u003e))\n  .catch(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eerr\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(err));\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; SyntaxError: Unexpected token D\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//       at Object.parse (native) ...\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNó código acima, quando executamos o método \u003ccode\u003eJSON.parse\u003c/code\u003e passando \u003ccode\u003edata\u003c/code\u003e como parâmetro ocorre um \u003ccode\u003ethrow SyntaxError(..)\u003c/code\u003e. O que causa a execução direta do \u003ccode\u003ecatch\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eComo podemos ver o \u003ccode\u003ethrow\u003c/code\u003e não saiu do escopo do nosso encadeamento, permitindo o tratamento do erro, exibindo uma mensagem para o usuário ou até mesmo corrigindo o problema, sem afetar o funcionamento da aplicação.\u003c/p\u003e\n\u003ch2\u003eParallelism and sequencing\u003c/h2\u003e\n\u003cp\u003ePor último, vou mostrar duas formas de executarmos operações assim dinamicamente, utilizando métodos que nós temos nativamente em um \u003ccode\u003eArray\u003c/code\u003e.\u003c/p\u003e\n\u003ch4\u003eParalellism\u003c/h4\u003e\n\u003cp\u003eImaginem que temos um array de itens que queremos salvar através de uma API, e queremos mandar salvar todos eles em paralelo e fazer algo assim que cada operação acabar.\u003c/p\u003e\n\u003cp\u003eExemplo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e items = [{ \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'es5'\u003c/span\u003e }, { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'es6'\u003c/span\u003e }, { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'es7'\u003c/span\u003e }, { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'es8'\u003c/span\u003e }];\n\nitems.forEach(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eitem\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n  fetch(\u003cspan class=\"hljs-string\"\u003e'/save'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'POST'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: obj })\n    .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(res));\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'es6 Done.'\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'es8 Done.'\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'es5 Done.'\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'es7 Done.'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNesse exemplo, podemos ver que não importa a ordem de finalização de nossas operações, queremos que a nossa callback seja executada assim que a operação acabar.\u003c/p\u003e\n\u003cp\u003eNo output do console, podemos ver que o es6 foi o primeiro a terminar, o es8 foi o segundo, es5 terceiro e es7 o quarto.\u003c/p\u003e\n\u003cp\u003eNão queremos que seja sequencial, na ordem que está no array, só queremos que todos sejam salvos em paralelo e que nossas callbacks sejam executadas assim que sua respectiva promise for resolvida.\u003c/p\u003e\n\u003ch4\u003eSequencing\u003c/h4\u003e\n\u003cp\u003eImaginem o mesmo array, a mesma operação, porém não queremos continuar salvando esses itens caso uma das operações falhe ou que queremos salva-los sequencialmente, na ordem que está no array.\u003c/p\u003e\n\u003cp\u003eExemplo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e items = [{ \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'es5'\u003c/span\u003e }, { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'es6'\u003c/span\u003e }, { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'es7'\u003c/span\u003e }, { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'es8'\u003c/span\u003e }];\n\nitems.reduce(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003esequence, obj\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e sequence\n    .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e fetch(\u003cspan class=\"hljs-string\"\u003e'/save'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'POST'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: obj }))\n    .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(res));\n}, \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.resolve());\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'es5 Done.'\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'es6 Done.'\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'es7 Done.'\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'es8 Done.'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNesse exemplo podemos ver que criamos um encadeamento dinamico, não importa a quantidade de itens que temos no array, todos eles serão salvos na ordem que estão no array.\u003c/p\u003e\n\u003cp\u003eO método reduce no final das contas, é a mesma coisa que esse código:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e items = [{ \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'es5'\u003c/span\u003e }, { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'es6'\u003c/span\u003e }, { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'es7'\u003c/span\u003e }, { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'es8'\u003c/span\u003e }];\n\n\u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e.resolve()\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e fetch(\u003cspan class=\"hljs-string\"\u003e'/save'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'POST'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: items[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] }))\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(res))\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e fetch(\u003cspan class=\"hljs-string\"\u003e'/save'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'POST'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: items[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] }))\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(res))\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e fetch(\u003cspan class=\"hljs-string\"\u003e'/save'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'POST'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: items[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e] }))\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(res))\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e fetch(\u003cspan class=\"hljs-string\"\u003e'/save'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'POST'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: items[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e] }))\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(res));\n\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'es5 Done.'\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'es6 Done.'\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'es7 Done.'\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \u0026gt; 'es8 Done.'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePorém, com \u003ccode\u003ereduce\u003c/code\u003e, não importa a quantidade de items, conseguimos fazer operações baseadas em dados dinamicos que estão dentro de um array.\u003c/p\u003e\n\u003ch2\u003eLinks úteis\u003c/h2\u003e\n\u003cp\u003eSe quiserem ver mais exemplos e se aprofundar mais, vejam esses links.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eO \u003ca href=\"https://ponyfoo.com/\"\u003eblog\u003c/a\u003e (ponyfoo) e \u003ca href=\"https://ponyfoo.com/articles/es6-promises-in-depth\"\u003eesse artigo\u003c/a\u003e do \u003ca href=\"https://twitter.com/nzgb\"\u003eNicolás Bevacqua\u003c/a\u003e que são sensacionais.\u003c/li\u003e\n\u003cli\u003eEsse \u003ca href=\"http://www.html5rocks.com/en/tutorials/es6/promises\"\u003eartigo\u003c/a\u003e do \u003ca href=\"https://twitter.com/jaffathecake\"\u003eJake Archibald\u003c/a\u003e é excelente.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org\"\u003eMDN\u003c/a\u003e é vida, e é claro que tem \u003ca href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise\"\u003edocumentação\u003c/a\u003e sobre Promise.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBom galera, é isso.\u003c/p\u003e\n\u003cp\u003ePromises são ótimas, espero que com esse post vocês consigam entender melhor como é o seu funcionamento e usa-las no dia a dia.\u003c/p\u003e\n\u003cp\u003eComentem ai o que acharam :)\u003c/p\u003e\n","metaData":{"layout":"post","title":"ES6 - Promises","slug":"es6-promises","description":"Entenda ES6 promises e suas vantagens em operações assíncronas no javascript.","date":"2016-04-08 18:40:43 -0300","language":"Brazilian Portuguese","excerpt":"Esse post será sobre promises\n\nLista dos tópicos que irei abordar:\n\n- O que é uma Promise?\n- States\n- Constructor\n- Instance Methods\n- Static Methods\n- Chaining\n- Error handling\n- Parallelism and sequencing\n","tags":["es6","js","promises","async"],"categories":["ES6 - O que mudou?"]},"slug":"es6-promises","build":true},"buildId":"3f7341cb-ca9e-4cc8-a6ce-c4ffbc9e5551","assetPrefix":"","nextExport":true,"err":null,"chunks":["components_social_share_0a49c1be05a44c2c22400be9bd51a7a9"]}
          module={}
          __NEXT_LOADED_PAGES__ = []
          __NEXT_LOADED_CHUNKS__ = []

          __NEXT_REGISTER_PAGE = function (route, fn) {
            __NEXT_LOADED_PAGES__.push({ route: route, fn: fn })
          }

          __NEXT_REGISTER_CHUNK = function (chunkName, fn) {
            __NEXT_LOADED_CHUNKS__.push({ chunkName: chunkName, fn: fn })
          }

          false
        </script><script async="" id="__NEXT_PAGE__/post" src="/_next/3f7341cb-ca9e-4cc8-a6ce-c4ffbc9e5551/page/post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/_next/3f7341cb-ca9e-4cc8-a6ce-c4ffbc9e5551/page/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/_next/3f7341cb-ca9e-4cc8-a6ce-c4ffbc9e5551/page/_error.js"></script><script async="" src="/_next/webpack/chunks/components_social_share_0a49c1be05a44c2c22400be9bd51a7a9-ba5984ee65adff24ec55.js"></script><script src="/_next/static/commons/main-b3a0a6ab00828187c287.js" async=""></script></body></html>