{"date":"08 Apr 2016","post":"<p>E ai galera, vamos continuar a série &quot;ES6 - O que mudou?&quot; :)</p>\n<p>Esse post será sobre promises</p>\n<p>Lista dos tópicos que irei abordar:</p>\n<ul>\n<li>O que é uma Promise?</li>\n<li>States</li>\n<li>Constructor</li>\n<li>Instance Methods</li>\n<li>Static Methods</li>\n<li>Chaining</li>\n<li>Error handling</li>\n<li>Parallelism and sequencing</li>\n</ul>\n<p>Vamos começar</p>\n<h2>O que é uma Promise?</h2>\n<p>Promise é um objeto usado para representar uma operação que ainda não foi completada, mas que eventualmente será finalizada no futuro.</p>\n<p>Esse objeto tem uma API que te permite fazer algo assim que ela acabar, recebendo o resultado dessa operação como parâmetro.</p>\n<p>&quot;Ta, mas eu já faço isso com callback&quot;</p>\n<p>Usar promises tem diversas vantagens, ela te permite manipular o resultado de uma ou várias operações assíncronas com mais facilidade e organização.\n<strong>Promise é uma das soluções para o callback hell.</strong></p>\n<p>Então, vamos ver um pequeno exemplo utilizando uma callback comum, para relembrar como fazemos operações assíncronas sem promises.</p>\n<p>Digamos que nós temos uma função <code>fetch</code> que faz requests HTTP para um servidor.</p>\n<pre><code class=\"language-javascript\">fetch(<span class=\"hljs-string\">'/data.json'</span>, (err, data) =&gt; {\n  <span class=\"hljs-keyword\">if</span> (err) {\n    <span class=\"hljs-comment\">// handle error</span>\n  }\n\n  <span class=\"hljs-comment\">// handle data from server</span>\n});\n</code></pre>\n<p>Ok, temos uma callback que recebe 2 parâmetros, um <code>err</code> (caso tenha ocorrido algum erro) e um <code>data</code> (dados que o servidor retornou para a nossa aplicação).</p>\n<p>Agora vamos ver como fazemos a mesma operação, sendo que a função <code>fetch</code> irá retornar uma promise dessa vez.</p>\n<pre><code class=\"language-javascript\">fetch(<span class=\"hljs-string\">'/data.json'</span>)\n  .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> {\n    <span class=\"hljs-comment\">// handle data from server</span>\n  })\n  .catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">err</span>) =&gt;</span> {\n    <span class=\"hljs-comment\">// handle error</span>\n  });\n</code></pre>\n<p>Dessa vez, chamamos 2 métodos, o <code>then</code> (que é chamado recebendo o dado do backend caso tudo tenha dado certo) e o <code>catch</code> (que é chamado recebendo um erro caso algo tenha dado errado), falarei mais sobre eles ao decorrer do post.</p>\n<h2>States</h2>\n<p>Uma promise só pode ter 3 possíveis estados:</p>\n<ul>\n<li>Pending</li>\n<li>Fulfilled</li>\n<li>Rejected</li>\n</ul>\n<p>Pendente, resolvida ou rejeitada.</p>\n<p>Caso o status atual seja pendente, a operação ainda não acabou e nenhuma callback passada para os métodos <code>then</code> ou <code>catch</code> foi invocada ainda.</p>\n<p>Se resolvida, o valor recebido é o valor que a operação retorna, quando a operação for executada sem problemas (parâmetro recebido no <code>then</code>).</p>\n<p>Se rejeitada, o valor é uma informação de erro, avisando que algo deu errado na operação e descrevendo a razão do acontecido (parâmetro recebido no <code>catch</code>).</p>\n<p><strong>Uma promise não pode ser resolvida e em seguida rejeitada ou vice e versa</strong>, a única transição de estado que ela sofre, é de pendente para uma das duas (resolvida ou rejeitada).</p>\n<h2>Constructor</h2>\n<p>Então, qual é a sintaxe usada para criarmos uma promise em ES6?</p>\n<p>Para criarmos uma instância de uma Promise, vamos usar o construtor <code>Promise(..)</code>.</p>\n<p>Como exemplo, vamos ver uma representação do que acontece dentro da função <code>fetch</code>, que foi usada anteriormente.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fetch</span> (<span class=\"hljs-params\">url</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve , reject</span>) =&gt;</span> {\n    <span class=\"hljs-comment\">// Faz o request HTTP (assíncrono)</span>\n    <span class=\"hljs-comment\">// dentro da callback do request chama `resolve(..)` ou `reject(..)`</span>\n  }); \n}\n</code></pre>\n<p>No código acima, dentro da função <code>fetch</code> estamos retornando uma nova Promise, criada por nós. O construtor dessa Promise, recebe uma função como parâmetro e essa função recebe dois parâmetros (<code>resolve</code> e <code>reject</code>), que também são funções.</p>\n<p>Então, quando queremos que a nossa promise, seja resolvida, chamamos a função que recebemos como parâmetro <code>resolve('Some data')</code>, e no caso de erro, chamamos o <code>reject('Error description')</code> que também recebemos como parâmetro.</p>\n<p>Vamos implementar um <code>fetch</code> falso que chamaria <code>resolve</code> depois de uma operação assíncrona, no exemplo usaremos o <code>setTimeout</code> para simular algo assíncrono.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fetch</span> (<span class=\"hljs-params\">url</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve , reject</span>) =&gt;</span> {\n    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> resolve(<span class=\"hljs-string\">'Some data'</span>), <span class=\"hljs-number\">1000</span>);\n  }); \n}\n\nfetch(<span class=\"hljs-string\">'/some-url'</span>)\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(data));\n\n<span class=\"hljs-comment\">// &gt; 'Some data'</span>\n</code></pre>\n<p>Como podemos ver no exemplo, a callback passada para o método <code>then</code> recebe o dado <code>'Some data'</code>, que é a string que passamos para a função <code>resolve</code>.</p>\n<p>Agora vamos ver um exemplo parecido, mas dessa vez chamaremos a função <code>reject</code>.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fetch</span> (<span class=\"hljs-params\">url</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve , reject</span>) =&gt;</span> {\n    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> reject(<span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'Something went wrong'</span>)), <span class=\"hljs-number\">1000</span>);\n  }); \n}\n\nfetch(<span class=\"hljs-string\">'/some-url'</span>)\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(data))\n  .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(err));\n\n<span class=\"hljs-comment\">// &gt; Error: Something went wrong</span>\n</code></pre>\n<p>Nesse exemplo, vemos a callback passada para o método <code>catch</code> sendo executada recebendo o dado <code>'Something went wrong'</code> como o parâmetro <code>err</code>.\nAlgo importante a citar, é que o <code>then</code> <strong>não é executado</strong> nesse caso, porque quando o <code>reject</code> é chamado, ele pula para o primeiro <code>catch</code>.</p>\n<h2>Instance Methods</h2>\n<p>Os métodos de uma instância de <code>Promise</code>, são o <code>then</code> e o <code>catch</code>.</p>\n<h4>then(..)</h4>\n<p>O método <code>then</code>, recebe uma callback de sucesso que será executada quando a promise for resolvida e uma segunda callback que será executada quando a promise for rejeitada.</p>\n<p>Exemplo:</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fetch</span> (<span class=\"hljs-params\">url</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve , reject</span>) =&gt;</span> {\n    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> reject(<span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'Something went wrong'</span>)), <span class=\"hljs-number\">1000</span>);\n  }); \n}\n\nfetch(<span class=\"hljs-string\">'/some-url'</span>)\n  .then(\n    <span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(data),\n    err =&gt; <span class=\"hljs-built_in\">console</span>.log(err)\n  );\n\n<span class=\"hljs-comment\">// &gt; Error: Something went wrong</span>\n</code></pre>\n<p>No exemplo acima, ao invés de usarmos <code>catch</code> passamos a callback de erro como o segundo parâmetro do <code>then</code>.</p>\n<p>No final das contas, não faz diferença entre fazer dessa forma ou usar o <code>catch</code>, eu pessoalmente gosto de usar o <code>catch</code>, acho que fica mais claro e organizado.</p>\n<h4>catch(..)</h4>\n<p>Como visto nos exemplos anteriores, o método <code>catch</code> recebe uma única callback, para tratar de um erro que possa ter ocorrido na operação, quando a promise é rejeitada.</p>\n<p><strong>Esses dois métodos retornam uma promise.</strong></p>\n<p>&quot;Oi? o.O&quot;</p>\n<p>Isso mesmo, como você já deve ter reparado nos exemplos, o <code>catch</code> está sendo chamado logo após o <code>then</code>, ou seja, é executado o método <code>catch</code> do retorno do <code>then</code>, isso funciona porque eles retornam uma promise.</p>\n<p>&quot;Então quer dizer que eu posso chamar o método <code>then</code> depois do <code>catch</code> também?&quot;</p>\n<p>Isso mesmo, podemos até chamar <code>then</code> depois de <code>then</code>.</p>\n<p>Mostrarei como isso faz sentido no tópico &quot;chaining&quot;.</p>\n<h2>Static Methods</h2>\n<p>Assim como podemos criar promises <code>new Promise((resolve, reject) =&gt; { .. })</code> podemos também chamar métodos estáticos dessa referência (<code>Promise</code>).</p>\n<p>Temos alguns métodos que podemos usar, que são bem úteis.</p>\n<ul>\n<li>all(iterable)</li>\n<li>race(iterable)</li>\n<li>resolve(value)</li>\n<li>reject(reason)</li>\n</ul>\n<h4>all([..])</h4>\n<p>O método <code>Promise.all(..)</code> recebe como parâmetro um array contendo promises e retorna uma promise que ou será resolvida apenas quando <strong>todas</strong> as promises do array estiverem resolvidas ou rejeitada assim que <strong>uma</strong> delas for rejeitada.</p>\n<p>Vamos ver um exemplo sem <code>catch</code>:</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">let</span> promises = [];\n\npromises.push(fetch(<span class=\"hljs-string\">'/some-url/1'</span>));\npromises.push(fetch(<span class=\"hljs-string\">'/some-url/2'</span>));\npromises.push(fetch(<span class=\"hljs-string\">'/some-url/3'</span>));\n\n<span class=\"hljs-built_in\">Promise</span>.all(promises)\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">responses</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(responses));\n\n<span class=\"hljs-comment\">// &gt; ['Some data 1  ', 'Some data 2', 'Some data 3']</span>\n</code></pre>\n<p>Então, recapitulando o que aconteceu acima</p>\n<ol>\n<li>Chamamos a nossa função <code>fetch</code> 3 vezes, para cada chamada é retornado uma promise diferente e adicionamos a promise retornada em um array.</li>\n<li>Acessamos o método estático <code>all</code> da referência global <code>Promise</code> e passamos o array (<code>promises</code>) como parâmetro.</li>\n<li>Como o método <code>all</code> retorna uma promise, estamos dando um <code>then</code> logo em seguida do <code>all</code>.</li>\n<li>A callback que passamos para o <code>then</code> está recebendo um array de resultados, os resultados estão na mesma ordem das promises que existem dentro do array, logo <code>responses[0]</code> seria a resposta de <code>promises[0]</code>.</li>\n</ol>\n<p>Vamos ver um exemplo igual, mas com uma das promises sendo rejeitada.</p>\n<p>Digamos que nesse exemplo, quando chamamos o <code>fetch</code> com <code>/some-url/2</code> a promise retornada seja rejeitada, teriamos um array de 2 promises que serão resolvidas e 1 rejeitada. Vamos ver o que acontece.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">let</span> promises = [];\n\npromises.push(fetch(<span class=\"hljs-string\">'/some-url/1'</span>));\npromises.push(fetch(<span class=\"hljs-string\">'/some-url/2'</span>));\npromises.push(fetch(<span class=\"hljs-string\">'/some-url/3'</span>));\n\n<span class=\"hljs-built_in\">Promise</span>.all(promises)\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">responses</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(responses))\n  .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(err));\n\n<span class=\"hljs-comment\">// &gt; Error: Something went wrong</span>\n</code></pre>\n<p>Então, aconteceu a mesma coisa quando temos uma promise rejeitada, o <code>then</code> foi ignorado, e fomos parar direto no <code>catch</code> com apenas uma mensagem de erro que veio da segunda promise do array.</p>\n<p>Vale citar que as outras operações ainda serão executadas, elas não são abortadas, porém, a callback do <code>then</code> mesmo assim não será chamada.</p>\n<h4>race([..])</h4>\n<p>O método <code>Promise.race(..)</code> também recebe como parâmetro um array contendo promises e retorna uma promise que ou será resolvida assim que <strong>qualquer uma</strong> das promises do array estiverem resolvida ou rejeitada assim que <strong>qualquer uma</strong> delas for rejeitada.</p>\n<p>Vamos ver um exemplo em que a segunda promise foi a primeira que foi resolvida:</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">let</span> promises = [];\n\npromises.push(fetch(<span class=\"hljs-string\">'/some-url/1'</span>));\npromises.push(fetch(<span class=\"hljs-string\">'/some-url/2'</span>));\npromises.push(fetch(<span class=\"hljs-string\">'/some-url/3'</span>));\n\n<span class=\"hljs-built_in\">Promise</span>.race(promises)\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(response))\n  .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(err));\n\n<span class=\"hljs-comment\">// &gt; 'Some data 2'</span>\n</code></pre>\n<p>O exemplo é muito similar com o do <code>Promise.all([..])</code>, a única difereça, é que estamos chamando o método <code>race</code> e em vez de recebermos um array de resultados na callback do then, estamos recebendo o resultado da promise que foi resolvida primeiro.</p>\n<p>No caso em que uma das promises for rejeitada, acontecerá a mesma coisa que aconteceu no exemplo do <code>Promise.all([..])</code>, a callback do <code>then</code> não será executada, e teremos o erro da promise que foi rejeitada.</p>\n<p>Lembrando de novo, que não acontece nenhum tipo de cancelamento das outras operações, promises não tem um método para isso.</p>\n<h4>resolve(..)</h4>\n<p>Esse método é bem simples, ele retorna uma promise já resolvida, e recebe como parâmetro o valor que a callback do <code>then</code> receberá.</p>\n<p>Exemplo:</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">let</span> promise = <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-string\">'My data'</span>);\n\npromise\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(data));\n\n<span class=\"hljs-comment\">// &gt; 'My data'</span>\n</code></pre>\n<h4>reject(..)</h4>\n<p>Esse método é o contrário do <code>Promise.resolve(..)</code>, ele retorna uma promise já rejeitada, e recebe como parâmetro o valor que a callback do <code>catch</code> receberá (o motivo da rejeição).</p>\n<p>Exemplo:</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">let</span> promise = <span class=\"hljs-built_in\">Promise</span>.reject(<span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'Some reason'</span>));\n\npromise\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(data))\n  .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">reason</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(reason));\n\n<span class=\"hljs-comment\">// &gt; Error: Some reason</span>\n</code></pre>\n<h2>Chaining</h2>\n<p>Então, lembram quando eu mencionei que podemos chamar <code>then</code> / <code>catch</code> seguido de outro <code>then</code> / <code>catch</code>?</p>\n<p>Isso se chama chaining, nesse tópico vamos descobrir que <code>then</code> não é o fim da estrada.</p>\n<p>Podemos usar essa tática para processar dados ou executar mais operações assíncronas.</p>\n<h4>Processando dados</h4>\n<p>Você pode processar um dado que foi retornado em uma promise e continuar encadeamento de &quot;thens&quot;, simplesmente retornando um novo valor dentro da callback.</p>\n<p>Exemplo:</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">let</span> promise = <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-number\">2</span>);\n\npromise\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> data + <span class=\"hljs-number\">1</span>)\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(data));\n\n<span class=\"hljs-comment\">// &gt; 3</span>\n</code></pre>\n<p>Acima, definimos uma promise já resolvida com o valor <code>2</code>, chamamos o método <code>then</code> passando uma callback que retorna <code>data + 1</code> e em seguida colocamos mais um <code>then</code> que loga seu <code>data</code>.</p>\n<p>O <code>data</code> do segundo <code>then</code> é o retorno do primeiro.</p>\n<p>Então isso te permite criar um flow de execução bem limpo.</p>\n<p>Digamos que chamamos o método <code>fetch</code> pegando um json, mas esse json vem como string, e queremos transforma-lo em objeto.</p>\n<p>Exemplo:</p>\n<pre><code class=\"language-javascript\">fetch(<span class=\"hljs-string\">'/data.json'</span>)\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> <span class=\"hljs-built_in\">JSON</span>.parse(data))\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">obj</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(obj));\n\n&gt; { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Promise'</span> }\n</code></pre>\n<p>Nesse exemplo, recebemos uma string <code>'{ &quot;name&quot;: &quot;Promise&quot; }'</code>, e transformamos ela em um objeto javascript chamando o método <code>JSON.parse</code> retornando o novo objeto para o próximo <code>then</code> que apenas loga o objeto.</p>\n<h4>Executando mais operações assíncronas</h4>\n<p>Você pode encadear &quot;thens&quot; para executar mais operações assíncronas, em sequência da anterior.</p>\n<p>Quando você retorna um valor na callback do <code>then</code> a callback do próximo <code>then</code> irá receber esse valor, mas se você retornar uma outra promise a próxima execução irá aguardar que essa promise seja resolvida ou rejeitada.</p>\n<p>Exemplo:</p>\n<pre><code class=\"language-javascript\">fetch(<span class=\"hljs-string\">'/data.json'</span>)\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> <span class=\"hljs-built_in\">JSON</span>.parse(data))\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">obj</span> =&gt;</span> { <span class=\"hljs-attr\">name</span>: obj.name, <span class=\"hljs-attr\">date</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>() })\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">obj</span> =&gt;</span> fetch(<span class=\"hljs-string\">'/save'</span>, { <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">'POST'</span>, <span class=\"hljs-attr\">body</span>: obj }))\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(response));\n\n<span class=\"hljs-comment\">// &gt; 'Done.'</span>\n</code></pre>\n<ol>\n<li>Usamos o <code>fetch</code> mais uma vez para fazer requests para uma API</li>\n<li>Pegamos um json da API</li>\n<li>Parseamos esse json</li>\n<li>Retornamos um novo objeto com a propriedade <code>name</code> e com uma nova propriedade <code>date</code> recebendo a data atual</li>\n<li>Usamos o fetch novamente passando esse novo objeto para outra rota da API</li>\n<li>Quando o novo request acabar, o próximo <code>then</code> será executado, e logamos a resposta.</li>\n</ol>\n<p>Agora, parem para pensar como isso ficaria sem promises...</p>\n<p>Pois é, quando disse que promise é uma das soluções para o callback hell, foi isso que eu quis dizer.</p>\n<h2>Error handling</h2>\n<p>Já vimos a utilização do <code>catch</code> em alguns exemplos, usaremos o <code>catch</code> bastante para tratar os erros que acontecem nessas operações com promises.</p>\n<p>A callback que passamos pro<code>catch</code> será chamada caso a etapa anterior a ele der algum erro ou retornar uma promise rejeitada.</p>\n<p>Exemplo:</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-string\">'Data'</span>)\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> <span class=\"hljs-built_in\">Promise</span>.reject(<span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'Fail'</span>)))\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'yay'</span>))\n  .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(err));\n\n<span class=\"hljs-comment\">// &gt; Error: Fail</span>\n</code></pre>\n<p>No exemplo, temos uma promise que foi resolvida, mas ao <code>then</code> ser executado, retornamos uma promise rejeitada, causando a execução do próximo <code>catch</code>.</p>\n<p>Com isso, dentro de &quot;thens&quot; podemos fazer checagens e retornar uma promise rejeitada para forçar a entrada no próximo <code>catch</code>, porque checamos que algo deu errado e no <code>catch</code> tratamos esse erro.</p>\n<p>O mesmo acontece quando um <code>throw</code> ocorre dentro de alguma etapa.</p>\n<p>Exemplo:</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-string\">'Data'</span>)\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> <span class=\"hljs-built_in\">JSON</span>.parse(data))\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'yay'</span>))\n  .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(err));\n\n<span class=\"hljs-comment\">// &gt; SyntaxError: Unexpected token D</span>\n<span class=\"hljs-comment\">//       at Object.parse (native) ...</span>\n</code></pre>\n<p>Nó código acima, quando executamos o método <code>JSON.parse</code> passando <code>data</code> como parâmetro ocorre um <code>throw SyntaxError(..)</code>. O que causa a execução direta do <code>catch</code>.</p>\n<p>Como podemos ver o <code>throw</code> não saiu do escopo do nosso encadeamento, permitindo o tratamento do erro, exibindo uma mensagem para o usuário ou até mesmo corrigindo o problema, sem afetar o funcionamento da aplicação.</p>\n<h2>Parallelism and sequencing</h2>\n<p>Por último, vou mostrar duas formas de executarmos operações assim dinamicamente, utilizando métodos que nós temos nativamente em um <code>Array</code>.</p>\n<h4>Paralellism</h4>\n<p>Imaginem que temos um array de itens que queremos salvar através de uma API, e queremos mandar salvar todos eles em paralelo e fazer algo assim que cada operação acabar.</p>\n<p>Exemplo:</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">let</span> items = [{ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'es5'</span> }, { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'es6'</span> }, { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'es7'</span> }, { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'es8'</span> }];\n\nitems.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> {\n  fetch(<span class=\"hljs-string\">'/save'</span>, { <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">'POST'</span>, <span class=\"hljs-attr\">body</span>: obj })\n    .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(res));\n});\n\n<span class=\"hljs-comment\">// &gt; 'es6 Done.'</span>\n<span class=\"hljs-comment\">// &gt; 'es8 Done.'</span>\n<span class=\"hljs-comment\">// &gt; 'es5 Done.'</span>\n<span class=\"hljs-comment\">// &gt; 'es7 Done.'</span>\n</code></pre>\n<p>Nesse exemplo, podemos ver que não importa a ordem de finalização de nossas operações, queremos que a nossa callback seja executada assim que a operação acabar.</p>\n<p>No output do console, podemos ver que o es6 foi o primeiro a terminar, o es8 foi o segundo, es5 terceiro e es7 o quarto.</p>\n<p>Não queremos que seja sequencial, na ordem que está no array, só queremos que todos sejam salvos em paralelo e que nossas callbacks sejam executadas assim que sua respectiva promise for resolvida.</p>\n<h4>Sequencing</h4>\n<p>Imaginem o mesmo array, a mesma operação, porém não queremos continuar salvando esses itens caso uma das operações falhe ou que queremos salva-los sequencialmente, na ordem que está no array.</p>\n<p>Exemplo:</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">let</span> items = [{ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'es5'</span> }, { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'es6'</span> }, { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'es7'</span> }, { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'es8'</span> }];\n\nitems.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">sequence, obj</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> sequence\n    .then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> fetch(<span class=\"hljs-string\">'/save'</span>, { <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">'POST'</span>, <span class=\"hljs-attr\">body</span>: obj }))\n    .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(res));\n}, <span class=\"hljs-built_in\">Promise</span>.resolve());\n\n<span class=\"hljs-comment\">// &gt; 'es5 Done.'</span>\n<span class=\"hljs-comment\">// &gt; 'es6 Done.'</span>\n<span class=\"hljs-comment\">// &gt; 'es7 Done.'</span>\n<span class=\"hljs-comment\">// &gt; 'es8 Done.'</span>\n</code></pre>\n<p>Nesse exemplo podemos ver que criamos um encadeamento dinamico, não importa a quantidade de itens que temos no array, todos eles serão salvos na ordem que estão no array.</p>\n<p>O método reduce no final das contas, é a mesma coisa que esse código:</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">let</span> items = [{ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'es5'</span> }, { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'es6'</span> }, { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'es7'</span> }, { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'es8'</span> }];\n\n<span class=\"hljs-built_in\">Promise</span>.resolve()\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> fetch(<span class=\"hljs-string\">'/save'</span>, { <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">'POST'</span>, <span class=\"hljs-attr\">body</span>: items[<span class=\"hljs-number\">0</span>] }))\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(res))\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> fetch(<span class=\"hljs-string\">'/save'</span>, { <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">'POST'</span>, <span class=\"hljs-attr\">body</span>: items[<span class=\"hljs-number\">1</span>] }))\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(res))\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> fetch(<span class=\"hljs-string\">'/save'</span>, { <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">'POST'</span>, <span class=\"hljs-attr\">body</span>: items[<span class=\"hljs-number\">2</span>] }))\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(res))\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> fetch(<span class=\"hljs-string\">'/save'</span>, { <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">'POST'</span>, <span class=\"hljs-attr\">body</span>: items[<span class=\"hljs-number\">3</span>] }))\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(res));\n\n<span class=\"hljs-comment\">// &gt; 'es5 Done.'</span>\n<span class=\"hljs-comment\">// &gt; 'es6 Done.'</span>\n<span class=\"hljs-comment\">// &gt; 'es7 Done.'</span>\n<span class=\"hljs-comment\">// &gt; 'es8 Done.'</span>\n</code></pre>\n<p>Porém, com <code>reduce</code>, não importa a quantidade de items, conseguimos fazer operações baseadas em dados dinamicos que estão dentro de um array.</p>\n<h2>Links úteis</h2>\n<p>Se quiserem ver mais exemplos e se aprofundar mais, vejam esses links.</p>\n<ul>\n<li>O <a href=\"https://ponyfoo.com/\">blog</a> (ponyfoo) e <a href=\"https://ponyfoo.com/articles/es6-promises-in-depth\">esse artigo</a> do <a href=\"https://twitter.com/nzgb\">Nicolás Bevacqua</a> que são sensacionais.</li>\n<li>Esse <a href=\"http://www.html5rocks.com/en/tutorials/es6/promises\">artigo</a> do <a href=\"https://twitter.com/jaffathecake\">Jake Archibald</a> é excelente.</li>\n<li><a href=\"https://developer.mozilla.org\">MDN</a> é vida, e é claro que tem <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise\">documentação</a> sobre Promise.</li>\n</ul>\n<p>Bom galera, é isso.</p>\n<p>Promises são ótimas, espero que com esse post vocês consigam entender melhor como é o seu funcionamento e usa-las no dia a dia.</p>\n<p>Comentem ai o que acharam :)</p>\n","metaData":{"layout":"post","title":"ES6 - Promises","slug":"es6-promises","description":"Entenda ES6 promises e suas vantagens em operações assíncronas no javascript.","date":"2016-04-08 18:40:43 -0300","language":"Brazilian Portuguese","excerpt":"Esse post será sobre promises\n\nLista dos tópicos que irei abordar:\n\n- O que é uma Promise?\n- States\n- Constructor\n- Instance Methods\n- Static Methods\n- Chaining\n- Error handling\n- Parallelism and sequencing\n","tags":["es6","js","promises","async"],"categories":["ES6 - O que mudou?"]},"slug":"es6-promises"}