{"date":"31 Mar 2016","post":"<p>E ai galera, continuando a série &quot;ES6 - O que mudou?&quot;, irei abordar nesse post, uma nova maneira de declarar funções anônimas em javascript.</p>\n<p>O objetivo é ser um post curto, explicativo e com bastante exemplos.</p>\n<p>Lista dos tópicos que irei abordar:</p>\n<ul>\n<li>Sintaxe</li>\n<li>Lexical this</li>\n</ul>\n<h2>Sintaxe</h2>\n<p>Então, começando com Sintaxe, vamos relembrar como que é uma função anônima sem ES6:</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> versions = [<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>];\n\nversions.map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">item</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'es'</span> + item;\n});\n\n<span class=\"hljs-comment\">// &gt; ['es5', 'es6', 'es7', 'es8']</span>\n</code></pre>\n<p>Beleza, como escrevo uma arrow function (ES6)?\nMuito fácil, baste tirar o <code>function</code> e adicionar <code>=&gt;</code> depois do <code>()</code> vamos ver um exemplo:</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">let</span> versions = [<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>];\n\nversions.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`es<span class=\"hljs-subst\">${item}</span>`</span>;\n});\n\n<span class=\"hljs-comment\">// &gt; ['es5', 'es6', 'es7', 'es8']</span>\n</code></pre>\n<p>Belo, não é?</p>\n<p>Caso nossa arrow function seja apenas de uma linha, podemos escreve-la sem as <code>{}</code> e caso receba apenas um parâmetro, podemos escreve-la sem o <code>()</code>.</p>\n<p>Mas cara, e se eu não receber parâmetro nenhum?<br>\nPrecisamos deixar o <code>()</code>, vazio mesmo.</p>\n<p>Vamos ver uns exemplos de arrow functions de apenas uma linha:</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">let</span> versions = [<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>];\n\n<span class=\"hljs-comment\">// Arrow functions com parâmetro</span>\nversions\n  .filter(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item &gt; <span class=\"hljs-number\">5</span>)\n  .map(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> <span class=\"hljs-string\">`es<span class=\"hljs-subst\">${item}</span>`</span>);\n\n<span class=\"hljs-comment\">// &gt; ['es6', 'es7', 'es8']</span>\n\n<span class=\"hljs-comment\">// Arrow function sem parâmetro</span>\n<span class=\"hljs-built_in\">document</span>.addEventListener(<span class=\"hljs-string\">'click'</span>, () =&gt; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'click'</span>));\n</code></pre>\n<p>É importante citar também, caso vocês não tenham notado, que arrow functions, quando são de uma linha só, não precisam do <code>return</code> para indicar o que ela está retornando, o valor já é retornado automaticamente.</p>\n<h2>Lexical this</h2>\n<p>Em javascript, temos a palavra-chave <code>this</code>, que tem o valor determinado pela forma como chamamos a função.</p>\n<p>A arrow function, tem seu <code>this</code> definido lexicalmente, seu <code>this</code> recebe o contexto de execução de onde a arrow function é declarada.</p>\n<p>Em uma arrow function definida em um contexto global, por exemplo, seu <code>this</code> assume o objeto global.</p>\n<p>Ou seja, a principal diferença entre a arrow function e a function normal que usamos, nesse tópico, é que a arrow function não modifica o <code>this</code> do contexto em que ela está inserida.</p>\n<p>Vamos ver um exemplo:</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Timer</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.seconds = <span class=\"hljs-number\">0</span>;\n\n  setInterval(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">this</span>.seconds++, <span class=\"hljs-number\">1000</span>);\n}\n\n<span class=\"hljs-keyword\">let</span> t = <span class=\"hljs-keyword\">new</span> Timer();\n\nsetTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(t.seconds), <span class=\"hljs-number\">5000</span>);\n\n<span class=\"hljs-comment\">// depois de 5 segundos...</span>\n<span class=\"hljs-comment\">// &gt; 5</span>\n</code></pre>\n<p>Vamos recapitular o código acima</p>\n<ol>\n<li>Criamos um construtor chamado <code>Timer</code>.</li>\n<li>No constructor <code>Timer</code> setamos a propriedade <code>seconds</code> dele para <code>0</code>.</li>\n<li>Fizemos um <code>setInterval</code> de 1 segundo, usando uma arrow function, adicionando +1 a propriedade <code>seconds</code>.</li>\n<li>Criamos um novo objeto a partir do construtor <code>Timer</code> (cada objeto terá seu próprio <code>this</code> devido a palavra-chave <code>new</code>).</li>\n<li>Executamos um <code>setTimeout</code> de 5 segundos, para logar a propriedade <code>seconds</code> de <code>t</code> (que é uma instancia de <code>Timer</code>).</li>\n</ol>\n<p>Se nós utilizassemos uma função normal como callback para o <code>setInterval</code>, teriamos problemas.\nSeu <code>this</code> não seria o <code>this</code> do contexto que desejamos.</p>\n<p>Porque?</p>\n<p>Lembra que comentei que a palavra-chave <code>this</code> tem seu valor determinado pela forma como chamamos a função?\nEntão, a função possívelmente está sendo chamada dentro de outro contexto do <code>setInterval</code>.</p>\n<p>Exemplo usando uma função normal:</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Timer</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.seconds = <span class=\"hljs-number\">0</span>;\n\n  setInterval(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.seconds++;\n  }, <span class=\"hljs-number\">1000</span>);\n}\n\n<span class=\"hljs-keyword\">let</span> t = <span class=\"hljs-keyword\">new</span> Timer();\n\nsetTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(t.seconds), <span class=\"hljs-number\">5000</span>);\n\n<span class=\"hljs-comment\">// depois de 5 segundos...</span>\n<span class=\"hljs-comment\">// &gt; 0</span>\n</code></pre>\n<p>Dessa vez, temos o valor <code>0</code> logado, porque para cada segundo que é executado a callback, o seu <code>this</code> não é o mesmo do contexto em que ela está inserida.</p>\n<h2>Use com consciência</h2>\n<p>Então galera, pra concluir o post rapidinho, quero citar que é bom entender que nem sempre uma arrow function é o ideal.</p>\n<p>É importante entender como o javascript interpreta uma arrow function, para saber o momento certo de usar.</p>\n<p>Ela é ótima para callbacks anônimas, que só servem para serem executadas naquela vez (para aquele caso), e em nenhum outro lugar.</p>\n<p>Voltando ao exemplo &quot;versions&quot;:</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">let</span> versions = [<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>];\n\nversions\n  .filter(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item &gt; <span class=\"hljs-number\">5</span>)\n  .map(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> <span class=\"hljs-string\">`es<span class=\"hljs-subst\">${item}</span>`</span>);\n</code></pre>\n<p>Então, as duas arrow functions que eu uso no map e no filter, são apenas callbacks, funções anônimas, que serão usadas para aquela operação e em nenhum outro lugar da aplicação.</p>\n<p>Um exemplo onde eu não usaria arrow functions, seria quando uso o padrão Revealing Module.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">let</span> MyModule = (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myMethod</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-comment\">// Doing something</span>\n  }\n  \n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myOtherMethod</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-comment\">// Doing something</span>\n  }\n  \n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">someMethod</span>: myMethod,\n    <span class=\"hljs-attr\">someOtherMethod</span>: myOtherMethod\n  };\n});\n</code></pre>\n<p>Porque?</p>\n<p>Bom, poderiamos declarar variáveis como arrow functions...\nMas lembrando, arrow functions são funções <strong>anônimas</strong>, logo, quando algum erro ocorrer, teriamos mais dificuldade de achar de onde ele veio no stack trace.</p>\n<p>A indicação de no erro seria <code>(anonymous function)</code>, ao invés do nome da função <code>myMethod</code>.</p>\n<p>Outro exemplo, seria quando precisamos usar a palavra-chave <code>this</code> associada ao objeto.\nVoltando no exemplo do Timer.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">let</span> Timer = (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">IIFE</span> (<span class=\"hljs-params\"></span>) </span>{\n<span class=\"hljs-meta\">  'use strict'</span>;\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Timer</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.seconds = <span class=\"hljs-number\">0</span>;\n\n    <span class=\"hljs-keyword\">this</span>.play();\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">pause</span> (<span class=\"hljs-params\"></span>) </span>{\n    clearInterval(<span class=\"hljs-keyword\">this</span>._interval);\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">play</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">this</span>._interval = setInterval(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">this</span>.seconds++, <span class=\"hljs-number\">1000</span>);\n  }\n\n  Timer.prototype.pause = pause;\n  Timer.prototype.play = play;\n\n  <span class=\"hljs-keyword\">return</span> Timer;\n})();\n\n\n<span class=\"hljs-keyword\">let</span> t = <span class=\"hljs-keyword\">new</span> Timer();\n<span class=\"hljs-keyword\">let</span> t2 = <span class=\"hljs-keyword\">new</span> Timer();\n<span class=\"hljs-keyword\">let</span> logger = setInterval(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(t.seconds, t2.seconds), <span class=\"hljs-number\">1000</span>);\n\nsetTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> t.pause(), <span class=\"hljs-number\">5000</span>);\n\nsetTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> t.play(), <span class=\"hljs-number\">9000</span>);\n\nsetTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  t.pause();\n  t2.pause();\n\n  clearInterval(logger);\n}, <span class=\"hljs-number\">15000</span>);\n\n<span class=\"hljs-comment\">// &gt; 1 1</span>\n<span class=\"hljs-comment\">// &gt; 2 2</span>\n<span class=\"hljs-comment\">// &gt; 3 3</span>\n<span class=\"hljs-comment\">// &gt; 4 4</span>\n<span class=\"hljs-comment\">// &gt; 5 5</span>\n<span class=\"hljs-comment\">// &gt; 5 6</span>\n<span class=\"hljs-comment\">// &gt; 5 7</span>\n<span class=\"hljs-comment\">// &gt; 5 8</span>\n<span class=\"hljs-comment\">// &gt; 5 9</span>\n<span class=\"hljs-comment\">// &gt; 5 10</span>\n<span class=\"hljs-comment\">// &gt; 6 11</span>\n<span class=\"hljs-comment\">// &gt; 7 12</span>\n<span class=\"hljs-comment\">// &gt; 8 13</span>\n<span class=\"hljs-comment\">// &gt; 9 14</span>\n<span class=\"hljs-comment\">// &gt; 10 15</span>\n</code></pre>\n<p>Nesse exemplo, estamos usando a mesma referência da função <code>pause</code> e <code>play</code> para o <code>Timer</code>, adicionado em seu <code>prototype</code>.</p>\n<p>Quando executamos <code>new Timer()</code> a função <code>Timer</code> é executada e é gerado um novo contexto para ela, porque usamos a palavra-chave <code>new</code>, então cada <code>Timer</code> criado dessa forma, gera um objeto com seu próprio <code>this</code>.</p>\n<p>Se usassemos arrow functions para essas duas funções que botamos no <code>prototype</code> do <code>Timer</code>, não teriamos o <code>this</code> correto, e sim o contexto global.</p>\n<p>Bom, é isso, finalizando mais um post rapidinho</p>\n<p>Espero que tenham gostado! :)</p>\n<p>Valeu galera!</p>\n","metaData":{"layout":"post","title":"ES6 - Arrow Functions","slug":"ES6-arrow-functions","description":"Entenda ES6 arrow functions e sua diferença para a função padrão do javascript.","date":"2016-03-31 00:40:43 -0300","language":"Brazilian Portuguese","excerpt":"E ai galera, continuando a série \"ES6 - O que mudou?\", irei abordar nesse post, uma nova maneira de declarar funções anônimas em javascript.\n\nO objetivo é ser um post curto, explicativo e com bastante exemplos.\n\nLista dos tópicos que irei abordar:\n\n- Sintaxe\n- Lexical this\n","tags":["es6","js"],"categories":["ES6 - O que mudou?"]},"slug":"ES6-arrow-functions"}