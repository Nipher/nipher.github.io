{"date":"27 Mar 2016","post":"<p>Fala galera, nesse post eu vou falar um pouco sobre a &quot;nova&quot; versão do JavaScript (ES6).</p>\n<p>Digo &quot;nova&quot; (entre aspas) porque a especificação dela foi aprovada no ano passado (2015), e já tem muitos browsers que suportam boa parte de suas funcionalidades, mas ainda vejo muita gente com dúvidas sobre ela.</p>\n<p>Esse post será parte de uma série de posts chamada &quot;ES6 - O que mudou?&quot;, ela será uma versão simplificada do primeiro tópico de uma talk que eu dei onde eu trabalho, quem quiser ver, é só acessar os <a href=\"http://www.slideshare.net/Hugeinc/what-is-new-on-es6\">slides</a>.</p>\n<p>O objetivo é escrever posts pequenos e com bastante exemplos.</p>\n<p>Lista dos assuntos que irei abordar no post:</p>\n<ul>\n<li>Let</li>\n<li>Const</li>\n<li>Blocks</li>\n<li>TDZ</li>\n</ul>\n<h2>Let &amp; Blocks</h2>\n<blockquote>\n<p><code>let</code> permite que você defina uma variável limitada pelo escopo do bloco <code>{}</code> de onde foi declarada.</p>\n</blockquote>\n<p>Diferente de <code>var</code>, que é limitada ao escopo de sua função.</p>\n<p>Anteriormente, no javascript, somente as funções criam escopo, diferente de outras linguagens, que criam escopo dentro de blocos, no ES6 com <code>let</code> isso muda, e passamos a ter escopo nos blocos também.</p>\n<p><strong>Exemplo:</strong></p>\n<pre><code class=\"language-javascript\">(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">IIFE</span> (<span class=\"hljs-params\"></span>) </span>{\n<span class=\"hljs-meta\">  'use strict'</span>;\n\n  <span class=\"hljs-keyword\">var</span> version = <span class=\"hljs-string\">'ES5'</span>; <span class=\"hljs-comment\">// Declara \"version\" dentro da função IIFE</span>\n\n  {\n    <span class=\"hljs-keyword\">let</span> version = <span class=\"hljs-string\">'ES6'</span>; <span class=\"hljs-comment\">// Declara \"version\" dentro do bloco \"{}\"</span>\n    <span class=\"hljs-built_in\">console</span>.log(version); <span class=\"hljs-comment\">// &gt; 'ES6'</span>\n  }\n\n  <span class=\"hljs-built_in\">console</span>.log(version); <span class=\"hljs-comment\">// &gt; 'ES5'</span>\n})();\n</code></pre>\n<p>Ok, vamos recapitular o que aconteceu acima</p>\n<ol>\n<li>Dentro da IIFE declaramos uma variável com o nome <code>version</code> limitada ao escopo da função</li>\n<li>Em seguida temos um bloco, sem nenhuma condição ou loop, um bloco puro (sim, podemos fazer isso em JS)</li>\n<li>Dentro desse bloco, declaramos outra variável <code>version</code></li>\n<li>Logamos a variável <code>version</code> (declarada dentro do bloco)</li>\n<li>Fora do bloco, logamos a variável <code>version</code> (que será a que foi declarada no início da função)</li>\n</ol>\n<p>Ou seja, as duas variáveis não conflitaram, porque elas estão declaradas em escopos diferentes, isso graças ao <code>let</code>, caso nós usássemos <code>var</code> para declarar a segunda variável chamada version, a variável anterior seria sobrescrita.</p>\n<p>Uma coisa bacana que <code>let</code> resolve, é quando você quer fazer um loop fazendo operações assíncronas para cada iteração (adicionando uma callback).</p>\n<p>Como assim?</p>\n<p>Bom, quando usamos um <code>for</code> loop adicionando callbacks e usando a variável <code>i</code> de alguma forma em cada callback, temos um problema, a variável <code>i</code> não será a mesma quando as operações assíncronas acabarem, porque todas as callbacks tem a mesma referência de <code>i</code>.</p>\n<p><strong>Exemplo usando <code>var</code>:</strong></p>\n<pre><code class=\"language-javascript\">(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">IIFE</span> (<span class=\"hljs-params\"></span>) </span>{\n<span class=\"hljs-meta\">  'use strict'</span>;\n  \n  <span class=\"hljs-keyword\">var</span> versions = [<span class=\"hljs-string\">'es5'</span>, <span class=\"hljs-string\">'es6'</span>, <span class=\"hljs-string\">'es7'</span>, <span class=\"hljs-string\">'es8'</span>];\n\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>, n = versions.length; i &lt; n; i++) {\n    <span class=\"hljs-built_in\">console</span>.log(i);\n    getNewName(versions[i], <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">newName</span>) </span>{\n      versions[i] = newName;\n      <span class=\"hljs-built_in\">console</span>.log(versions, i, version[i]);\n    });\n  }\n})();\n\n&gt; <span class=\"hljs-number\">0</span>\n&gt; <span class=\"hljs-number\">1</span>\n&gt; <span class=\"hljs-number\">2</span>\n&gt; <span class=\"hljs-number\">3</span>\n\n&gt; [<span class=\"hljs-string\">'es5'</span>, <span class=\"hljs-string\">'es6'</span>, <span class=\"hljs-string\">'es7'</span>, <span class=\"hljs-string\">'es8'</span>] <span class=\"hljs-number\">4</span> <span class=\"hljs-literal\">undefined</span>\n&gt; [<span class=\"hljs-string\">'es5'</span>, <span class=\"hljs-string\">'es6'</span>, <span class=\"hljs-string\">'es7'</span>, <span class=\"hljs-string\">'es8'</span>, <span class=\"hljs-string\">'es5'</span>] <span class=\"hljs-number\">4</span> <span class=\"hljs-string\">'es5'</span>\n&gt; [<span class=\"hljs-string\">'es5'</span>, <span class=\"hljs-string\">'es6'</span>, <span class=\"hljs-string\">'es7'</span>, <span class=\"hljs-string\">'es8'</span>, <span class=\"hljs-string\">'es2015'</span>] <span class=\"hljs-number\">4</span> <span class=\"hljs-string\">'es2015'</span>\n&gt; [<span class=\"hljs-string\">'es5'</span>, <span class=\"hljs-string\">'es6'</span>, <span class=\"hljs-string\">'es7'</span>, <span class=\"hljs-string\">'es8'</span>, <span class=\"hljs-string\">'es2016'</span>] <span class=\"hljs-number\">4</span> <span class=\"hljs-string\">'es2016'</span>\n</code></pre>\n<p>Vamos recapitular de novo?</p>\n<ol>\n<li>Tenho um array com versões do javascript</li>\n<li>Para cada item do array, eu chamo o método <code>getNewName</code> passando a versão e uma callback (pois ele é assíncrono)</li>\n<li>Dentro da callback eu uso a variável <code>i</code> para acessar o item desejado</li>\n<li>Dá tudo errado</li>\n</ol>\n<p>A referência da variável <code>i</code> é a mesma, para todas as operações dentro do <code>for</code>, ou seja, como a callback será executada depois de um certo período de tempo, o valor de <code>i</code> não será o mesmo, no nosso caso, ele terá o valor <code>4</code> porque estamos aumentando seu valor a cada iteração.</p>\n<p>Então, o que acontece quando usamos <code>let</code> ao invés de <code>var</code>?</p>\n<p><strong>Exemplo usando <code>let</code>:</strong></p>\n<pre><code class=\"language-javascript\">(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">IIFE</span> (<span class=\"hljs-params\"></span>) </span>{\n<span class=\"hljs-meta\">  'use strict'</span>;\n  \n  <span class=\"hljs-keyword\">var</span> versions = [<span class=\"hljs-string\">'es5'</span>, <span class=\"hljs-string\">'es6'</span>, <span class=\"hljs-string\">'es7'</span>, <span class=\"hljs-string\">'es8'</span>];\n\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>, n = versions.length; i &lt; n; i++) {\n    <span class=\"hljs-built_in\">console</span>.log(i);\n    getNewName(versions[i], <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">newName</span>) </span>{\n      versions[i] = newName;\n      <span class=\"hljs-built_in\">console</span>.log(versions, i, version[i]);\n    });\n  }\n})();\n\n&gt; <span class=\"hljs-number\">0</span>\n&gt; <span class=\"hljs-number\">1</span>\n&gt; <span class=\"hljs-number\">2</span>\n&gt; <span class=\"hljs-number\">3</span>\n\n&gt; [<span class=\"hljs-string\">'es5'</span>, <span class=\"hljs-string\">'es6'</span>, <span class=\"hljs-string\">'es7'</span>, <span class=\"hljs-string\">'es8'</span>] <span class=\"hljs-number\">0</span> <span class=\"hljs-string\">'es5'</span>\n&gt; [<span class=\"hljs-string\">'es5'</span>, <span class=\"hljs-string\">'es2015'</span>, <span class=\"hljs-string\">'es7'</span>, <span class=\"hljs-string\">'es8'</span>] <span class=\"hljs-number\">1</span> <span class=\"hljs-string\">'es2015'</span>\n&gt; [<span class=\"hljs-string\">'es5'</span>, <span class=\"hljs-string\">'es2015'</span>, <span class=\"hljs-string\">'es2016'</span>, <span class=\"hljs-string\">'es8'</span>] <span class=\"hljs-number\">2</span> <span class=\"hljs-string\">'es2016'</span>\n&gt; [<span class=\"hljs-string\">'es5'</span>, <span class=\"hljs-string\">'es2015'</span>, <span class=\"hljs-string\">'es2016'</span>, <span class=\"hljs-string\">'es2017'</span>] <span class=\"hljs-number\">3</span> <span class=\"hljs-string\">'es2017'</span>\n</code></pre>\n<p>Recapitulando...</p>\n<p>Então, como disse no exemplo com <code>var</code>, a referência da variável <code>i</code> é a mesma para todas as operações dentro do <code>for</code>, porque o escopo dela é a função, com <code>let</code>, o escopo da variável <code>i</code> é o bloco, logo, para cada iteração feita, a referência de <code>i</code> será diferente, por isso mesmo executando uma callback depois de um certo período de tempo usando <code>i</code> não tem problema, pois a referência é única para cada iteração.</p>\n<h2>Const</h2>\n<blockquote>\n<p><code>Const</code> declara uma constante, uma referência de somente leitura para um valor alocado em memória.</p>\n</blockquote>\n<p>Ou seja, diferente de <code>var</code> ou <code>let</code>, se tentarmos alterar a referência que a <code>const</code> declarada está guardando, ganhamos um <code>TypeError</code>.</p>\n<p><strong>Exemplo alterando a referência:</strong></p>\n<pre><code class=\"language-javascript\">(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">IIFE</span> (<span class=\"hljs-params\"></span>) </span>{\n<span class=\"hljs-meta\">  'use strict'</span>;\n\n  <span class=\"hljs-keyword\">const</span> VERSION = <span class=\"hljs-string\">'ES6'</span>;\n\n  VERSION = <span class=\"hljs-string\">'ES5'</span>;\n})();\n\n&gt; <span class=\"hljs-string\">'Uncaught TypeError: Assignment to constant variable'</span>\n</code></pre>\n<p><strong>O fato dela ser uma const`, não quer dizer que o valor que ela guarda é imutável!</strong></p>\n<p>Ihalá, como assim o.O?</p>\n<p>Com um exemplo deve ficar fácil de entender</p>\n<p><strong>Exemplo alterando o valor:</strong></p>\n<pre><code class=\"language-javascript\">(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">IIFE</span> (<span class=\"hljs-params\"></span>) </span>{\n<span class=\"hljs-meta\">  'use strict'</span>;\n\n  <span class=\"hljs-keyword\">const</span> VERSIONS = {\n    <span class=\"hljs-attr\">es6</span>: <span class=\"hljs-string\">'ES6'</span>,\n    <span class=\"hljs-attr\">es7</span>: <span class=\"hljs-string\">'ES2016'</span>,\n    <span class=\"hljs-attr\">es8</span>: <span class=\"hljs-string\">'ES2017'</span>\n  };\n\n  VERSIONS.es6 = <span class=\"hljs-string\">'ES2015'</span>;\n\n  <span class=\"hljs-built_in\">console</span>.log(VERSIONS);\n})();\n\n&gt; {<span class=\"hljs-attr\">es6</span>: <span class=\"hljs-string\">'ES2015'</span>, <span class=\"hljs-attr\">es7</span>: <span class=\"hljs-string\">'ES2016'</span>, <span class=\"hljs-attr\">es8</span>: <span class=\"hljs-string\">'ES2017'</span>}\n</code></pre>\n<p>Então, acho que agora ficou claro, o erro só ocorre quando você tenta substituir a referência que uma <code>const</code> está guardando.</p>\n<p>Mais um exemplo de erro, dessa vez usando um objeto igual no exemplo anterior.</p>\n<p><strong>Exemplo alterando a referência:</strong></p>\n<pre><code class=\"language-javascript\">(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">IIFE</span> (<span class=\"hljs-params\"></span>) </span>{\n<span class=\"hljs-meta\">  'use strict'</span>;\n\n  <span class=\"hljs-keyword\">const</span> VERSIONS = {\n    <span class=\"hljs-attr\">es6</span>: <span class=\"hljs-string\">'ES6'</span>,\n    <span class=\"hljs-attr\">es7</span>: <span class=\"hljs-string\">'ES2016'</span>,\n    <span class=\"hljs-attr\">es8</span>: <span class=\"hljs-string\">'ES2017'</span>\n  };\n\n  VERSIONS = {\n    <span class=\"hljs-attr\">es6</span>: <span class=\"hljs-string\">'ES2015'</span>,\n    <span class=\"hljs-attr\">es7</span>: <span class=\"hljs-string\">'ES2016'</span>,\n    <span class=\"hljs-attr\">es8</span>: <span class=\"hljs-string\">'ES2017'</span>\n  };\n})();\n\n&gt; <span class=\"hljs-string\">'Uncaught TypeError: Assignment to constant variable'</span>\n</code></pre>\n<h2>Const &amp; Blocks</h2>\n<blockquote>\n<p><code>const</code> é limitada ao escopo do bloco <code>{}</code>.</p>\n</blockquote>\n<p>Isso mesmo, <code>const</code> se comporta igual ao <code>let</code> quando se trata do escopo em que foram declaradas.</p>\n<p><strong>Exemplo:</strong></p>\n<pre><code class=\"language-javascript\">(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">IIFE</span> (<span class=\"hljs-params\"></span>) </span>{\n<span class=\"hljs-meta\">  'use strict'</span>;\n\n  <span class=\"hljs-keyword\">const</span> VERSION = <span class=\"hljs-string\">'ES5'</span>;\n  \n  {\n    <span class=\"hljs-keyword\">const</span> VERSION = <span class=\"hljs-string\">'ES6'</span>;\n    <span class=\"hljs-built_in\">console</span>.log(VERSION);\n  }\n\n  <span class=\"hljs-built_in\">console</span>.log(VERSION);\n})();\n\n&gt; <span class=\"hljs-string\">'ES6'</span>\n&gt; <span class=\"hljs-string\">'ES5'</span>\n</code></pre>\n<h2>TDZ (Temporal Dead Zone)</h2>\n<blockquote>\n<p><code>let</code> e <code>const</code> farão o &quot;hoist&quot; do valor para o topo do bloco. Porém, usa-los antes da linha de código onde foram declarados, causa um <code>ReferenceError</code>.</p>\n</blockquote>\n<p>Os valores estão no &quot;temporal dead zone&quot;, que existe do começo do bloco <code>{}</code> até a linha onde ocorre a declaração do valor (usando <code>const</code> ou <code>let</code>).</p>\n<p>Com <code>var</code>, a variável sempre é declarada como <code>undefined</code> no início da função, logo não temos o temporal dead zone quando usamos <code>var</code>.</p>\n<p><strong>Exemplo:</strong></p>\n<pre><code class=\"language-javascript\">(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">IIFE</span> (<span class=\"hljs-params\"></span>) </span>{\n<span class=\"hljs-meta\">  'use strict'</span>;\n  \n  <span class=\"hljs-built_in\">console</span>.log(version); <span class=\"hljs-comment\">// undefined</span>\n  <span class=\"hljs-built_in\">console</span>.log(letVersion);\n  <span class=\"hljs-comment\">// Uncaught ReferenceError: letVersion is not defined</span>\n  <span class=\"hljs-built_in\">console</span>.log(VERSION);\n  <span class=\"hljs-comment\">// Uncaught ReferenceError: VERSION is not defined</span>\n\n  <span class=\"hljs-keyword\">var</span> version = <span class=\"hljs-string\">'es6'</span>;\n  <span class=\"hljs-keyword\">let</span> letVersion = <span class=\"hljs-string\">'ES6'</span>;\n  <span class=\"hljs-keyword\">const</span> VERSION = <span class=\"hljs-string\">'ES6'</span>;\n})();\n</code></pre>\n<p>Então, recapitulando esse último exemplo.</p>\n<p>Com variáveis declaradas com <code>var</code>, não importa em qual momento da função ela está sendo declarada, o javascript fará a declaração dela como <code>undefined</code> no ínicio da função.</p>\n<p>Com <code>let</code>, ele faz o hoisting para o início do bloco, porém não permite você acessar a variável até a sua declaração, mesmo sem atribuição alguma, por exemplo:</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">let</span> version;\n</code></pre>\n<p>E com <code>const</code>, funciona da mesma forma que o <code>let</code>.</p>\n<p>Bom galera, espero que tenham gostado do post, qualquer feedback será muito bem vindo.<br>\nSe tiverem algo a acrescentar, comentem ai em baixo :)</p>\n","metaData":{"layout":"post","title":"ES6 - Let, Const & Blocks","slug":"ES6-let-const-blocks","description":"Aprenda a diferença das novas variáveis no ES6 e o que mudou para o Javascript antigo.","date":"2016-03-27 16:13:43 -0300","language":"Brazilian Portuguese","excerpt":"Aprenda a diferença das novas variáveis no ES6 e o que mudou para o Javascript antigo.\n\nLista dos assuntos que irei abordar no post:\n\n- Let\n- Const\n- Blocks\n- TDZ\n","tags":["es6","js"],"categories":["ES6 - O que mudou?"]},"slug":"ES6-let-const-blocks"}